/*!
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
import { __awaiter, __decorate, __param, __metadata } from 'tslib';
import { InjectionToken, Component, Inject, Optional, Injector, Injectable, Input, Directive, TemplateRef, ViewContainerRef, VERSION, NgModule } from '@angular/core';
import { Router, NavigationStart } from '@angular/router';
import { Location } from '@angular/common';
import { OktaAuth, AuthSdkError, toRelativeUrl } from '@okta/okta-auth-js';
import { filter, mergeMap } from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs';
import { compare } from 'compare-versions';

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@okta/okta-auth-js';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/router';
const OKTA_CONFIG = new InjectionToken('okta.config.angular');
const OKTA_AUTH = new InjectionToken('okta.auth');

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
let OktaCallbackComponent = class OktaCallbackComponent {
    constructor(config, oktaAuth, injector) {
        this.config = config;
        this.oktaAuth = oktaAuth;
        this.injector = injector;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Parse code or tokens from the URL, store tokens in the TokenManager, and redirect back to the originalUri
                yield this.oktaAuth.handleLoginRedirect();
            }
            catch (e) {
                // Callback from social IDP. Show custom login page to continue.
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore Supports auth-js v5 & v6
                const isInteractionRequiredError = this.oktaAuth.isInteractionRequiredError || this.oktaAuth.idx.isInteractionRequiredError;
                if (isInteractionRequiredError(e) && this.injector) {
                    const { onAuthResume, onAuthRequired } = this.config;
                    const callbackFn = onAuthResume || onAuthRequired;
                    if (callbackFn) {
                        callbackFn(this.oktaAuth, this.injector);
                        return;
                    }
                }
                this.error = e.toString();
            }
        });
    }
};
OktaCallbackComponent.ɵfac = function OktaCallbackComponent_Factory(t) { return new (t || OktaCallbackComponent)(ɵngcc0.ɵɵdirectiveInject(OKTA_CONFIG), ɵngcc0.ɵɵdirectiveInject(OKTA_AUTH), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector, 8)); };
OktaCallbackComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: OktaCallbackComponent, selectors: [["ng-component"]], decls: 2, vars: 1, template: function OktaCallbackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.error);
    } }, encapsulation: 2 });
OktaCallbackComponent = __decorate([ __param(0, Inject(OKTA_CONFIG)),
    __param(1, Inject(OKTA_AUTH)),
    __param(2, Optional()),
    __metadata("design:paramtypes", [Object, OktaAuth,
        Injector])
], OktaCallbackComponent);

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
let OktaAuthGuard = class OktaAuthGuard {
    constructor(config, oktaAuth, injector) {
        this.config = config;
        this.oktaAuth = oktaAuth;
        this.injector = injector;
        this.updateAuthStateListener = (authState) => {
            if (!authState.isAuthenticated) {
                this.handleLogin(this.state.url);
            }
        };
        this.onAuthRequired = this.config.onAuthRequired;
        // Unsubscribe updateAuthStateListener when route change
        const router = injector.get(Router);
        router.events.pipe(filter((e) => e instanceof NavigationStart && this.state && this.state.url !== e.url)).subscribe(() => {
            this.oktaAuth.authStateManager.unsubscribe(this.updateAuthStateListener);
        });
    }
    canLoad(route, segments) {
        return __awaiter(this, void 0, void 0, function* () {
            this.onAuthRequired = route.data && route.data.onAuthRequired || this.onAuthRequired;
            const isAuthenticated = yield this.oktaAuth.isAuthenticated();
            if (isAuthenticated) {
                return true;
            }
            const originalUri = segments[0].path;
            yield this.handleLogin(originalUri);
            return false;
        });
    }
    /**
     * Gateway for protected route. Returns true if there is a valid accessToken,
     * otherwise it will cache the route and start the login flow.
     * @param route
     * @param state
     */
    canActivate(route, state) {
        return __awaiter(this, void 0, void 0, function* () {
            // Track states for current route
            this.state = state;
            this.onAuthRequired = route.data && route.data.onAuthRequired || this.onAuthRequired;
            // Protect the route after accessing
            this.oktaAuth.authStateManager.subscribe(this.updateAuthStateListener);
            const isAuthenticated = yield this.oktaAuth.isAuthenticated();
            if (isAuthenticated) {
                return true;
            }
            yield this.handleLogin(state.url);
            return false;
        });
    }
    canActivateChild(route, state) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.canActivate(route, state);
        });
    }
    handleLogin(originalUri) {
        return __awaiter(this, void 0, void 0, function* () {
            // Store the current path
            this.oktaAuth.setOriginalUri(originalUri);
            if (this.onAuthRequired) {
                this.onAuthRequired(this.oktaAuth, this.injector);
            }
            else {
                this.oktaAuth.signInWithRedirect();
            }
        });
    }
};
OktaAuthGuard.ɵfac = function OktaAuthGuard_Factory(t) { return new (t || OktaAuthGuard)(ɵngcc0.ɵɵinject(OKTA_CONFIG), ɵngcc0.ɵɵinject(OKTA_AUTH), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
OktaAuthGuard.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: OktaAuthGuard, factory: function (t) { return OktaAuthGuard.ɵfac(t); } });
OktaAuthGuard = __decorate([ __param(0, Inject(OKTA_CONFIG)),
    __param(1, Inject(OKTA_AUTH)),
    __metadata("design:paramtypes", [Object, OktaAuth,
        Injector])
], OktaAuthGuard);

const defaultAuthState = {
    isAuthenticated: false
};
let OktaAuthStateService = class OktaAuthStateService {
    constructor(oktaAuth) {
        this.oktaAuth = oktaAuth;
        this._authState = new BehaviorSubject(defaultAuthState);
        // only expose readonly property
        this.authState$ = this._authState.asObservable();
        this.updateAuthState = this.updateAuthState.bind(this);
        // set initial authState
        const initialAuthState = this.oktaAuth.authStateManager.getAuthState() || defaultAuthState;
        this._authState.next(initialAuthState);
        // subscribe to future changes
        this.oktaAuth.authStateManager.subscribe(this.updateAuthState);
    }
    ngOnDestroy() {
        this.oktaAuth.authStateManager.unsubscribe(this.updateAuthState);
    }
    // Observes as true when any group input can match groups from user claims 
    hasAnyGroups(groups) {
        return this.authState$.pipe(mergeMap(({ isAuthenticated, idToken }) => __awaiter(this, void 0, void 0, function* () {
            // return false when not authenticated or openid is not in scopes
            if (!isAuthenticated || !idToken) {
                return false;
            }
            // transform inputs to consistent object format
            if (typeof groups === 'string') {
                groups = { groups: [groups] };
            }
            if (Array.isArray(groups)) {
                groups = { groups };
            }
            const key = Object.keys(groups)[0];
            const value = groups[key];
            // groups or custom claims is available in idToken
            if (idToken.claims[key]) {
                return value.some((authority) => idToken.claims[key].includes(authority));
            }
            // try /userinfo endpoint when thin idToken (no groups claim) is returned
            // https://developer.okta.com/docs/concepts/api-access-management/#tokens-and-scopes
            const userInfo = yield this.oktaAuth.getUser();
            if (!userInfo[key]) {
                return false;
            }
            return value.some((authority) => userInfo[key].includes(authority));
        })));
    }
    updateAuthState(authState) {
        this._authState.next(authState);
    }
};
OktaAuthStateService.ɵfac = function OktaAuthStateService_Factory(t) { return new (t || OktaAuthStateService)(ɵngcc0.ɵɵinject(OKTA_AUTH)); };
OktaAuthStateService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: OktaAuthStateService, factory: function (t) { return OktaAuthStateService.ɵfac(t); } });
OktaAuthStateService = __decorate([ __param(0, Inject(OKTA_AUTH)),
    __metadata("design:paramtypes", [OktaAuth])
], OktaAuthStateService);

let OktaHasAnyGroupDirective = class OktaHasAnyGroupDirective {
    constructor(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    templateRef, viewContainer, authStateService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.authStateService = authStateService;
    }
    set oktaHasAnyGroup(groups) {
        this.authStateService.hasAnyGroups(groups)
            .subscribe(isAuthorized => {
            // don't update UI if no state change
            if (isAuthorized === this.previousIsAuthorized) {
                return;
            }
            this.previousIsAuthorized = isAuthorized;
            this.viewContainer.clear();
            if (isAuthorized) {
                this.viewContainer.createEmbeddedView(this.templateRef);
            }
        });
    }
};
OktaHasAnyGroupDirective.ɵfac = function OktaHasAnyGroupDirective_Factory(t) { return new (t || OktaHasAnyGroupDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(OktaAuthStateService)); };
OktaHasAnyGroupDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: OktaHasAnyGroupDirective, selectors: [["", "oktaHasAnyGroup", ""]], inputs: { oktaHasAnyGroup: "oktaHasAnyGroup" } });
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], OktaHasAnyGroupDirective.prototype, "oktaHasAnyGroup", null);
OktaHasAnyGroupDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef,
        ViewContainerRef,
        OktaAuthStateService])
], OktaHasAnyGroupDirective);

var packageInfo = {
    'name': '@okta/okta-angular',
    'version': '5.2.0',
    'authJSMinSupportedVersion': '5.3.1'
};

/*
 * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */
function oktaAuthFactory(config) {
    return config.oktaAuth;
}
let OktaAuthModule = class OktaAuthModule {
    constructor(config, location, router) {
        const { oktaAuth } = config;
        const isAuthJsSupported = oktaAuth._oktaUserAgent && compare(oktaAuth._oktaUserAgent.getVersion(), packageInfo.authJSMinSupportedVersion, '>=');
        if (!isAuthJsSupported) {
            throw new AuthSdkError(`Passed in oktaAuth is not compatible with the SDK, minimum supported okta-auth-js version is ${packageInfo.authJSMinSupportedVersion}.`);
        }
        // Add Okta UA
        oktaAuth._oktaUserAgent.addEnvironment(`${packageInfo.name}/${packageInfo.version}`);
        oktaAuth._oktaUserAgent.addEnvironment(`Angular/${VERSION.full}`);
        // Provide a default implementation of `restoreOriginalUri`
        if (!oktaAuth.options.restoreOriginalUri && router && location) {
            oktaAuth.options.restoreOriginalUri = (_, originalUri) => __awaiter(this, void 0, void 0, function* () {
                const baseUrl = window.location.origin + location.prepareExternalUrl('');
                const routePath = toRelativeUrl(originalUri || '/', baseUrl);
                router.navigateByUrl(routePath);
            });
        }
        // Start services
        oktaAuth.start();
    }
};
OktaAuthModule.ɵfac = function OktaAuthModule_Factory(t) { return new (t || OktaAuthModule)(ɵngcc0.ɵɵinject(OKTA_CONFIG), ɵngcc0.ɵɵinject(ɵngcc2.Location, 8), ɵngcc0.ɵɵinject(ɵngcc3.Router, 8)); };
OktaAuthModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: OktaAuthModule });
OktaAuthModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        OktaAuthGuard,
        OktaAuthStateService,
        {
            provide: OKTA_AUTH,
            useFactory: oktaAuthFactory,
            deps: [OKTA_CONFIG]
        },
    ] });
OktaAuthModule = __decorate([ __param(0, Inject(OKTA_CONFIG)),
    __param(1, Optional()),
    __param(2, Optional()),
    __metadata("design:paramtypes", [Object, Location,
        Router])
], OktaAuthModule);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OktaCallbackComponent, [{
        type: Component,
        args: [{
                template: `<div>{{error}}</div>`
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [OKTA_CONFIG]
            }] }, { type: ɵngcc1.OktaAuth, decorators: [{
                type: Inject,
                args: [OKTA_AUTH]
            }] }, { type: ɵngcc0.Injector, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OktaAuthGuard, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [OKTA_CONFIG]
            }] }, { type: ɵngcc1.OktaAuth, decorators: [{
                type: Inject,
                args: [OKTA_AUTH]
            }] }, { type: ɵngcc0.Injector }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OktaAuthStateService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.OktaAuth, decorators: [{
                type: Inject,
                args: [OKTA_AUTH]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OktaHasAnyGroupDirective, [{
        type: Directive,
        args: [{ selector: '[oktaHasAnyGroup]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: OktaAuthStateService }]; }, { oktaHasAnyGroup: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OktaAuthModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    OktaCallbackComponent,
                    OktaHasAnyGroupDirective,
                ],
                exports: [
                    OktaCallbackComponent,
                    OktaHasAnyGroupDirective,
                ],
                providers: [
                    OktaAuthGuard,
                    OktaAuthStateService,
                    {
                        provide: OKTA_AUTH,
                        useFactory: oktaAuthFactory,
                        deps: [OKTA_CONFIG]
                    },
                ]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [OKTA_CONFIG]
            }] }, { type: ɵngcc2.Location, decorators: [{
                type: Optional
            }] }, { type: ɵngcc3.Router, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(OktaAuthModule, { declarations: [OktaCallbackComponent, OktaHasAnyGroupDirective], exports: [OktaCallbackComponent, OktaHasAnyGroupDirective] }); })();

export { OKTA_AUTH, OKTA_CONFIG, OktaAuthGuard, OktaAuthModule, OktaAuthStateService, OktaCallbackComponent, oktaAuthFactory as ɵa, OktaHasAnyGroupDirective as ɵb };

//# sourceMappingURL=okta-angular.js.map