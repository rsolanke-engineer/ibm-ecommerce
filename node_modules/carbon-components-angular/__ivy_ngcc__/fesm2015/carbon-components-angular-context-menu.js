/**
 *
 * carbon-angular v0.0.0 | carbon-components-angular-context-menu.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { CommonModule } from '@angular/common';
import { IconModule } from 'carbon-components-angular/icon';
import { ReplaySubject, Subscription } from 'rxjs';
import { Component, HostBinding, Injectable, EventEmitter, Input, Output, ElementRef, HostListener, ContentChild, Optional, NgModule } from '@angular/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from 'carbon-components-angular/icon';

const _c0 = ["*"];
const _c1 = "[_nghost-%COMP%] {\n\t\t\tdisplay: list-item;\n\t\t\tlist-style: none;\n\t\t}";
const _c2 = function (a0, a1, a2, a3) { return { "bx--context-menu--root": a0, "bx--menu--root": a1, "bx--context-menu--open": a2, "bx--menu--open": a3 }; };
const _c3 = function (a0, a1) { return { "left.px": a0, "top.px": a1 }; };
function ContextMenuItemComponent__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 7);
} }
function ContextMenuItemComponent__svg_svg_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 8);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ibmIcon", ctx_r1.icon);
} }
function ContextMenuItemComponent__svg_svg_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "svg", 9);
} }
class ContextMenuDividerComponent {
    constructor() {
        this.dividerContextClass = true; // deprecated
        this.dividerClass = true;
        this.role = "separator";
    }
}
ContextMenuDividerComponent.ɵfac = function ContextMenuDividerComponent_Factory(t) { return new (t || ContextMenuDividerComponent)(); };
ContextMenuDividerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContextMenuDividerComponent, selectors: [["ibm-context-menu-divider"]], hostVars: 5, hostBindings: function ContextMenuDividerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("bx--context-menu-divider", ctx.dividerContextClass)("bx--menu-divider", ctx.dividerClass);
    } }, decls: 0, vars: 0, template: function ContextMenuDividerComponent_Template(rf, ctx) { }, styles: [_c1] });
ContextMenuDividerComponent.propDecorators = {
    dividerContextClass: [{ type: HostBinding, args: ["class.bx--context-menu-divider",] }],
    dividerClass: [{ type: HostBinding, args: ["class.bx--menu-divider",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuDividerComponent, [{
        type: Component,
        args: [{ selector: "ibm-context-menu-divider", template: "", styles: ["\n\t\t:host {\n\t\t\tdisplay: list-item;\n\t\t\tlist-style: none;\n\t\t}\n\t"] }]
    }], function () { return []; }, { dividerContextClass: [{
            type: HostBinding,
            args: ["class.bx--context-menu-divider"]
        }], dividerClass: [{
            type: HostBinding,
            args: ["class.bx--menu-divider"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }] }); })();

class ContextMenuSelectionService {
    constructor() {
        this.selectionSubject = new ReplaySubject(1);
        this.value = [];
        this.selectionObservable = this.selectionSubject.asObservable();
    }
    selectRadio(value) {
        if (!value) {
            return;
        }
        this.selectionSubject.next(value);
        this.value = [value];
    }
    selectCheckbox(value) {
        if (!value) {
            return;
        }
        if (this.value.includes(value)) {
            this.value = this.value.filter(v => v !== value);
        }
        else {
            this.value.push(value);
        }
        this.selectionSubject.next(this.value);
    }
    selectCheckboxes(value) {
        if (!value) {
            return;
        }
        this.value = value;
        this.selectionSubject.next(value);
    }
}
ContextMenuSelectionService.ɵfac = function ContextMenuSelectionService_Factory(t) { return new (t || ContextMenuSelectionService)(); };
ContextMenuSelectionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuSelectionService, factory: ContextMenuSelectionService.ɵfac });
/** @nocollapse */
ContextMenuSelectionService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuSelectionService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class ContextMenuGroupComponent {
    constructor(contextMenuSelectionService) {
        this.contextMenuSelectionService = contextMenuSelectionService;
        this.role = "none";
        this.label = null;
        this.value = [];
        this.type = null;
        this.valueChange = new EventEmitter();
        this.subscription = new Subscription();
    }
    ngOnInit() {
        const { selectionObservable } = this.contextMenuSelectionService;
        const subscription = selectionObservable.subscribe(value => {
            this.valueChange.emit(value);
        });
        this.subscription.add(subscription);
    }
    ngOnChanges(changes) {
        if (changes.value) {
            if (this.type === "radio") {
                this.contextMenuSelectionService.selectRadio(changes.value.currentValue);
            }
            if (this.type === "checkbox") {
                this.contextMenuSelectionService.selectCheckboxes(changes.value.currentValue);
            }
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ContextMenuGroupComponent.ɵfac = function ContextMenuGroupComponent_Factory(t) { return new (t || ContextMenuGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ContextMenuSelectionService)); };
ContextMenuGroupComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContextMenuGroupComponent, selectors: [["ibm-context-menu-group"]], hostVars: 1, hostBindings: function ContextMenuGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { label: "label", value: "value", type: "type" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([ContextMenuSelectionService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["role", "group"]], template: function ContextMenuGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.label);
    } }, styles: [_c1] });
/** @nocollapse */
ContextMenuGroupComponent.ctorParameters = () => [
    { type: ContextMenuSelectionService }
];
ContextMenuGroupComponent.propDecorators = {
    role: [{ type: HostBinding, args: ["attr.role",] }],
    label: [{ type: Input }],
    value: [{ type: Input }],
    type: [{ type: Input }],
    valueChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuGroupComponent, [{
        type: Component,
        args: [{ selector: "ibm-context-menu-group", template: `
		<ul role="group" [attr.aria-label]="label">
			<ng-content></ng-content>
		</ul>
	`, providers: [ContextMenuSelectionService], styles: ["\n\t\t:host {\n\t\t\tdisplay: list-item;\n\t\t\tlist-style: none;\n\t\t}\n\t"] }]
    }], function () { return [{ type: ContextMenuSelectionService }]; }, { role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], type: [{
            type: Input
        }], valueChange: [{
            type: Output
        }] }); })();

class ContextMenuComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.root = true;
        this.open = false;
        this.position = {
            left: 0,
            top: 0
        };
    }
    ngOnChanges(changes) {
        if (changes.open && changes.open.currentValue) {
            this.focusMenu();
        }
    }
    focusMenu() {
        // wait until the next tick to let the DOM settle before changing the focus
        const list = this.elementRef.nativeElement.querySelector("ul");
        setTimeout(() => {
            if (this.root) {
                list.focus();
            }
            else {
                const firstOption = list.querySelector(".bx--context-menu-option, .bx--menu-option");
                firstOption.focus();
            }
        });
    }
    handleNavigation(event) {
        const list = this.elementRef.nativeElement.querySelector("ul");
        const subMenus = Array.from(list.querySelectorAll("ul[role=menu]"));
        const menuItems = Array.from(list.querySelectorAll(".bx--context-menu-option, .bx--menu-option"))
            .filter(menuItem => !subMenus.some(subMenu => subMenu.contains(menuItem)));
        const currentIndex = menuItems.findIndex(menuItem => parseInt(menuItem.getAttribute("tabindex"), 10) === 0);
        const currentMenuItem = menuItems[currentIndex];
        switch (event.key) {
            case "ArrowDown": {
                if (document.activeElement === list) {
                    menuItems[0].focus();
                }
                else {
                    if (currentIndex !== -1 && currentIndex < menuItems.length - 1) {
                        menuItems[currentIndex + 1].focus();
                    }
                }
                break;
            }
            case "ArrowUp": {
                if (document.activeElement === list) {
                    menuItems[menuItems.length - 1].focus();
                }
                else {
                    if (currentIndex !== -1 && currentIndex > 0) {
                        menuItems[currentIndex - 1].focus();
                    }
                }
                break;
            }
            case "ArrowRight": {
                if (currentIndex !== -1 && subMenus.some(subMenu => currentMenuItem.contains(subMenu))) {
                    currentMenuItem.click();
                }
                break;
            }
            case "ArrowLeft": {
                const parent = currentMenuItem.parentElement.closest(".bx--context-menu-option, .bx--menu-option");
                if (parent) {
                    parent.focus();
                }
                break;
            }
        }
    }
    getDimensions() {
        const element = this.elementRef.nativeElement.querySelector("ul");
        return element.getBoundingClientRect();
    }
}
ContextMenuComponent.ɵfac = function ContextMenuComponent_Factory(t) { return new (t || ContextMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ContextMenuComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContextMenuComponent, selectors: [["ibm-context-menu"]], hostBindings: function ContextMenuComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function ContextMenuComponent_keydown_HostBindingHandler($event) { return ctx.handleNavigation($event); });
    } }, inputs: { root: "root", open: "open", position: "position" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 2, vars: 10, consts: [["role", "menu", "tabindex", "-1", 1, "bx--context-menu", "bx--menu", 3, "ngClass", "ngStyle"]], template: function ContextMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction4(2, _c2, ctx.root, ctx.root, ctx.open, ctx.open))("ngStyle", ɵngcc0.ɵɵpureFunction2(7, _c3, ctx.position.left, ctx.position.top));
    } }, dependencies: [ɵngcc1.NgClass, ɵngcc1.NgStyle], encapsulation: 2 });
/** @nocollapse */
ContextMenuComponent.ctorParameters = () => [
    { type: ElementRef }
];
ContextMenuComponent.propDecorators = {
    root: [{ type: Input }],
    open: [{ type: Input }],
    position: [{ type: Input }],
    handleNavigation: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuComponent, [{
        type: Component,
        args: [{
                selector: "ibm-context-menu",
                template: `
		<ul
			class="bx--context-menu bx--menu"
			[ngClass]="{
				'bx--context-menu--root': root,
				'bx--menu--root': root,
				'bx--context-menu--open': open,
				'bx--menu--open': open
			}"
			role="menu"
			tabindex="-1"
			[ngStyle]="{
				'left.px': position.left,
				'top.px': position.top
			}">
			<ng-content></ng-content>
		</ul>
	`
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { root: [{
            type: Input
        }], open: [{
            type: Input
        }], position: [{
            type: Input
        }], handleNavigation: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }] }); })();

class ContextMenuItemComponent {
    constructor(elementRef, contextMenuSelectionService) {
        this.elementRef = elementRef;
        this.contextMenuSelectionService = contextMenuSelectionService;
        this.optionContextClass = true; // deprecated
        this.optionClass = true;
        this.role = "menuitem";
        this.tabindex = -1;
        this.ariaHasPopup = null;
        this.ariaExpanded = null;
        this.label = "";
        this.info = "";
        this.type = null;
        this.checked = false;
        this.icon = "";
        this.value = "";
        this.checkedChange = new EventEmitter();
        this.hasChildren = false;
        this.selectable = false;
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        switch (this.type) {
            case "checkbox": {
                this.role = "menuitemcheckbox";
                this.selectable = true;
                break;
            }
            case "radio": {
                this.role = "menuitemradio";
                this.selectable = true;
                break;
            }
            default: {
                this.role = "menuitem";
            }
        }
        if (this.type && this.contextMenuSelectionService && this.value) {
            const { selectionObservable } = this.contextMenuSelectionService;
            const subscription = selectionObservable.subscribe((value) => {
                if (this.type === "radio") {
                    this.handleSelection(value === this.value);
                }
                if (this.type === "checkbox") {
                    this.handleSelection(value.includes(this.value));
                }
            });
            this.subscriptions.add(subscription);
        }
    }
    ngAfterContentInit() {
        if (this.childContextMenu) {
            this.hasChildren = true;
            this.ariaHasPopup = true;
            this.ariaExpanded = false;
            this.childContextMenu.root = false;
        }
    }
    handleClick(event) {
        event.stopPropagation();
        if (this.hasChildren) {
            this.openSubMenu();
            this.childContextMenu.focusMenu();
        }
        if (this.type) {
            this.handleSelection(!this.checked);
        }
        if (this.contextMenuSelectionService) {
            if (this.type === "radio") {
                this.contextMenuSelectionService.selectRadio(this.value);
            }
            if (this.type === "checkbox") {
                this.contextMenuSelectionService.selectCheckbox(this.value);
            }
        }
    }
    handleSelection(selected) {
        this.checked = selected;
        this.checkedChange.emit(this.checked);
    }
    openSubMenu() {
        if (this.childContextMenu) {
            this.childContextMenu.open = true;
            this.ariaExpanded = true;
            const dimensions = this.getDimensions();
            this.childContextMenu.position.left = dimensions.left + dimensions.width;
            // subtract 4px to account for margins
            this.childContextMenu.position.top = dimensions.top - 4;
        }
    }
    closeSubMenu() {
        if (this.childContextMenu) {
            this.childContextMenu.open = false;
            this.ariaExpanded = false;
        }
    }
    handleMouseOver() {
        this.openSubMenu();
    }
    handleMouseOut() {
        this.closeSubMenu();
    }
    handleFocus() {
        this.tabindex = 0;
        if (this.hasChildren && this.ariaExpanded) {
            this.closeSubMenu();
        }
    }
    handleBlur() {
        this.tabindex = -1;
    }
    focusItem() {
        this.elementRef.nativeElement.focus();
    }
    getDimensions() {
        const element = this.elementRef.nativeElement.querySelector(".bx--context-menu-option__content, .bx--menu-option__content");
        return element.getBoundingClientRect();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
ContextMenuItemComponent.ɵfac = function ContextMenuItemComponent_Factory(t) { return new (t || ContextMenuItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ContextMenuSelectionService, 8)); };
ContextMenuItemComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ContextMenuItemComponent, selectors: [["ibm-context-menu-item"]], contentQueries: function ContextMenuItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ContextMenuComponent, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childContextMenu = _t.first);
    } }, hostVars: 8, hostBindings: function ContextMenuItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.enter", function ContextMenuItemComponent_keydown_enter_HostBindingHandler($event) { return ctx.handleClick($event); })("keydown.space", function ContextMenuItemComponent_keydown_space_HostBindingHandler($event) { return ctx.handleClick($event); })("click", function ContextMenuItemComponent_click_HostBindingHandler($event) { return ctx.handleClick($event); })("mouseover", function ContextMenuItemComponent_mouseover_HostBindingHandler() { return ctx.handleMouseOver(); })("mouseout", function ContextMenuItemComponent_mouseout_HostBindingHandler() { return ctx.handleMouseOut(); })("focus", function ContextMenuItemComponent_focus_HostBindingHandler() { return ctx.handleFocus(); })("blur", function ContextMenuItemComponent_blur_HostBindingHandler() { return ctx.handleBlur(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex)("aria-haspopup", ctx.ariaHasPopup)("aria-expanded", ctx.ariaExpanded);
        ɵngcc0.ɵɵclassProp("bx--context-menu-option", ctx.optionContextClass)("bx--menu-option", ctx.optionClass);
    } }, inputs: { label: "label", info: "info", type: "type", checked: "checked", icon: "icon", value: "value" }, outputs: { checkedChange: "checkedChange" }, ngContentSelectors: _c0, decls: 10, vars: 6, consts: [[1, "bx--context-menu-option__content", "bx--menu-option__content"], [1, "bx--context-menu-option__icon", "bx--menu-option__icon"], ["ibmIcon", "checkmark", "size", "16", 4, "ngIf"], ["size", "16", 3, "ibmIcon", 4, "ngIf"], [1, "bx--context-menu-option__label", "bx--menu-option__label", 3, "title"], [1, "bx--context-menu-option__info", "bx--menu-option__info"], ["ibmIcon", "caret--right", "size", "16", 4, "ngIf"], ["ibmIcon", "checkmark", "size", "16"], ["size", "16", 3, "ibmIcon"], ["ibmIcon", "caret--right", "size", "16"]], template: function ContextMenuItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, ContextMenuItemComponent__svg_svg_2_Template, 1, 0, "svg", 2);
        ɵngcc0.ɵɵtemplate(3, ContextMenuItemComponent__svg_svg_3_Template, 1, 1, "svg", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "span", 4);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵtemplate(8, ContextMenuItemComponent__svg_svg_8_Template, 1, 0, "svg", 6);
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵprojection(9);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selectable && ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.selectable && ctx.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.info, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasChildren);
    } }, dependencies: [ɵngcc1.NgIf, ɵngcc2.IconDirective], styles: [_c1] });
/** @nocollapse */
ContextMenuItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ContextMenuSelectionService, decorators: [{ type: Optional }] }
];
ContextMenuItemComponent.propDecorators = {
    optionContextClass: [{ type: HostBinding, args: ["class.bx--context-menu-option",] }],
    optionClass: [{ type: HostBinding, args: ["class.bx--menu-option",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    tabindex: [{ type: HostBinding, args: ["attr.tabindex",] }],
    ariaHasPopup: [{ type: HostBinding, args: ["attr.aria-haspopup",] }],
    ariaExpanded: [{ type: HostBinding, args: ["attr.aria-expanded",] }],
    label: [{ type: Input }],
    info: [{ type: Input }],
    type: [{ type: Input }],
    checked: [{ type: Input }],
    icon: [{ type: Input }],
    value: [{ type: Input }],
    checkedChange: [{ type: Output }],
    childContextMenu: [{ type: ContentChild, args: [ContextMenuComponent, { static: true },] }],
    handleClick: [{ type: HostListener, args: ["keydown.enter", ["$event"],] }, { type: HostListener, args: ["keydown.space", ["$event"],] }, { type: HostListener, args: ["click", ["$event"],] }],
    handleMouseOver: [{ type: HostListener, args: ["mouseover",] }],
    handleMouseOut: [{ type: HostListener, args: ["mouseout",] }],
    handleFocus: [{ type: HostListener, args: ["focus",] }],
    handleBlur: [{ type: HostListener, args: ["blur",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuItemComponent, [{
        type: Component,
        args: [{ selector: "ibm-context-menu-item", template: `
		<div class="bx--context-menu-option__content bx--menu-option__content">
			<div class="bx--context-menu-option__icon bx--menu-option__icon">
				<svg *ngIf="selectable && checked" ibmIcon="checkmark" size="16"></svg>
				<svg *ngIf="!selectable && icon" [ibmIcon]="icon" size="16"></svg>
			</div>
			<span class="bx--context-menu-option__label bx--menu-option__label" [title]="label">{{label}}</span>
			<div class="bx--context-menu-option__info bx--menu-option__info">
				{{info}}
				<svg *ngIf="hasChildren" ibmIcon="caret--right" size="16"></svg>
			</div>
		</div>
		<ng-content></ng-content>
	`, styles: ["\n\t\t:host {\n\t\t\tdisplay: list-item;\n\t\t\tlist-style: none;\n\t\t}\n\t"] }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ContextMenuSelectionService, decorators: [{
                type: Optional
            }] }]; }, { optionContextClass: [{
            type: HostBinding,
            args: ["class.bx--context-menu-option"]
        }], optionClass: [{
            type: HostBinding,
            args: ["class.bx--menu-option"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], tabindex: [{
            type: HostBinding,
            args: ["attr.tabindex"]
        }], ariaHasPopup: [{
            type: HostBinding,
            args: ["attr.aria-haspopup"]
        }], ariaExpanded: [{
            type: HostBinding,
            args: ["attr.aria-expanded"]
        }], label: [{
            type: Input
        }], info: [{
            type: Input
        }], type: [{
            type: Input
        }], checked: [{
            type: Input
        }], icon: [{
            type: Input
        }], value: [{
            type: Input
        }], checkedChange: [{
            type: Output
        }], handleClick: [{
            type: HostListener,
            args: ["keydown.enter", ["$event"]]
        }, {
            type: HostListener,
            args: ["keydown.space", ["$event"]]
        }, {
            type: HostListener,
            args: ["click", ["$event"]]
        }], handleMouseOver: [{
            type: HostListener,
            args: ["mouseover"]
        }], handleMouseOut: [{
            type: HostListener,
            args: ["mouseout"]
        }], handleFocus: [{
            type: HostListener,
            args: ["focus"]
        }], handleBlur: [{
            type: HostListener,
            args: ["blur"]
        }], childContextMenu: [{
            type: ContentChild,
            args: [ContextMenuComponent, { static: true }]
        }] }); })();

class ContextMenuModule {
}
ContextMenuModule.ɵfac = function ContextMenuModule_Factory(t) { return new (t || ContextMenuModule)(); };
ContextMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ContextMenuModule });
ContextMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule, IconModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ContextMenuModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ContextMenuDividerComponent,
                    ContextMenuGroupComponent,
                    ContextMenuItemComponent,
                    ContextMenuComponent
                ],
                exports: [
                    ContextMenuDividerComponent,
                    ContextMenuGroupComponent,
                    ContextMenuItemComponent,
                    ContextMenuComponent
                ],
                imports: [CommonModule, IconModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContextMenuModule, { declarations: function () { return [ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent]; }, imports: function () { return [CommonModule, IconModule]; }, exports: function () { return [ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ContextMenuSelectionService as ɵa, ContextMenuModule, ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent };

//# sourceMappingURL=carbon-components-angular-context-menu.js.map