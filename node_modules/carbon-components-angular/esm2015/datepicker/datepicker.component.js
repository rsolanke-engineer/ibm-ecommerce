/**
 *
 * carbon-angular v0.0.0 | datepicker.component.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter, ViewEncapsulation, ElementRef, HostListener, ViewChild } from "@angular/core";
import rangePlugin from "flatpickr/dist/plugins/rangePlugin";
import flatpickr from "flatpickr";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { carbonFlatpickrMonthSelectPlugin } from "./carbon-flatpickr-month-select";
import { Subscription } from "rxjs";
import * as languages from "flatpickr/dist/l10n/index";
import { DatePickerInput } from "carbon-components-angular/datepicker-input";
import { ElementService } from "carbon-components-angular/utils";
import { I18n } from "carbon-components-angular/i18n";
/**
 * [See demo](../../?path=/story/components-date-picker--single)
 *
 * <example-url>../../iframe.html?id=components-date-picker--single</example-url>
 */
export class DatePicker {
    constructor(elementRef, elementService, i18n) {
        this.elementRef = elementRef;
        this.elementService = elementService;
        this.i18n = i18n;
        /**
         * Select calendar range mode
         */
        this.range = false;
        /**
         * Format of date
         *
         * For reference: https://flatpickr.js.org/formatting/
         */
        this.dateFormat = "m/d/Y";
        /**
         * Language of the flatpickr calendar.
         *
         * For reference of the possible locales:
         * https://github.com/flatpickr/flatpickr/blob/master/src/l10n/index.ts
         */
        this.language = "en";
        this.placeholder = "mm/dd/yyyy";
        /**
         * Aria label added to datepicker's calendar container.
         */
        this.ariaLabel = "calendar container";
        /**
         * The pattern for the underlying input element
         * @deprecated as of v4 - switch to inputPattern
         */
        this.pattern = "^\\d{1,2}/\\d{1,2}/\\d{4}$";
        this.id = `datepicker-${DatePicker.datePickerCount++}`;
        this.theme = "dark";
        this.disabled = false;
        /**
         * Set to `true` to display the invalid state.
         */
        this.invalid = false;
        /**
          * Set to `true` to show a warning (contents set by warningText)
          */
        this.warn = false;
        this.size = "md";
        /**
         * Set to `true` to display the invalid state for the second datepicker input.
         */
        this.rangeInvalid = false;
        /**
          * Set to `true` to show a warning in the second datepicker input (contents set by rangeWarningText)
          */
        this.rangeWarn = false;
        this.skeleton = false;
        this.plugins = [];
        this.valueChange = new EventEmitter();
        this._value = [];
        this._flatpickrOptions = {
            allowInput: true
        };
        this.flatpickrBaseOptions = {
            mode: "single",
            dateFormat: "m/d/Y",
            plugins: this.plugins,
            onOpen: () => {
                this.updateClassNames();
                this.updateAttributes();
                this.updateCalendarListeners();
            },
            onClose: () => {
                // This makes sure that the `flatpickrInstance selectedDates` are in sync with the values of
                // the inputs when the calendar closes.
                if (this.range && this.flatpickrInstance) {
                    if (this.flatpickrInstance.selectedDates.length !== 2) {
                        // we could `this.flatpickrInstance.clear()` but it insists on opening the second picker
                        // in some cases, so instead we do this
                        this.setDateValues([]);
                        this.doSelect([]);
                        return;
                    }
                    const inputValue = this.input.input.nativeElement.value;
                    const rangeInputValue = this.rangeInput.input.nativeElement.value;
                    if (inputValue || rangeInputValue) {
                        const parseDate = (date) => this.flatpickrInstance.parseDate(date, this.dateFormat);
                        this.setDateValues([parseDate(inputValue), parseDate(rangeInputValue)]);
                        this.doSelect(this.flatpickrInstance.selectedDates);
                    }
                }
            },
            onDayCreate: (_dObj, _dStr, _fp, dayElem) => {
                dayElem.classList.add("bx--date-picker__day");
            },
            nextArrow: this.rightArrowHTML(),
            prevArrow: this.leftArrowHTML(),
            value: this.value
        };
        this.flatpickrInstance = null;
        this.visibilitySubscription = new Subscription();
        this.onTouched = () => { };
        this.propagateChange = (_) => { };
        this.preventCalendarClose = event => event.stopPropagation();
    }
    /**
     * The pattern for the underlying input element
     */
    set inputPattern(value) {
        this.pattern = value;
    }
    get inputPattern() {
        return this.pattern;
    }
    set value(v) {
        if (!v) {
            v = [];
        }
        this._value = v;
    }
    get value() {
        return this._value;
    }
    set flatpickrOptions(options) {
        this._flatpickrOptions = Object.assign({}, this._flatpickrOptions, options);
    }
    get flatpickrOptions() {
        const plugins = [...this.plugins, carbonFlatpickrMonthSelectPlugin];
        if (this.range) {
            plugins.push(rangePlugin({ input: `#${this.id}-rangeInput`, position: "left" }));
        }
        return Object.assign({}, this._flatpickrOptions, this.flatpickrBaseOptions, {
            mode: this.range ? "range" : "single",
            plugins,
            dateFormat: this.dateFormat,
            locale: languages.default[this.language]
        });
    }
    ngOnInit() {
        // if i18n is set to anything other than en we'll want to change the language
        // otherwise we'll just use the local setting
        if (this.i18n.getLocale() !== "en") {
            this.i18n.getLocaleObservable().subscribe(locale => {
                this.language = locale;
                this.resetFlatpickrInstance();
            });
        }
    }
    ngOnChanges(changes) {
        // Reset the flatpickr instance on input changes that affect flatpickr.
        const flatpickrChangeKeys = [
            "range",
            "dateFormat",
            "language",
            "id",
            "value",
            "plugins",
            "flatpickrOptions"
        ];
        const changeKeys = Object.keys(changes);
        if (changeKeys.some(key => flatpickrChangeKeys.includes(key))) {
            this.resetFlatpickrInstance(changes.value);
        }
    }
    ngAfterViewInit() {
        this.visibilitySubscription = this.elementService
            .visibility(this.elementRef.nativeElement, this.elementRef.nativeElement)
            .subscribe(value => {
            if (this.isFlatpickrLoaded() && this.flatpickrInstance.isOpen) {
                this.flatpickrInstance._positionCalendar(this.elementRef.nativeElement.querySelector(`#${this.id}-input`));
                if (!value.visible) {
                    this.flatpickrInstance.close();
                }
            }
        });
        setTimeout(() => {
            this.addInputListeners();
        }, 0);
    }
    // because the actual view may be delayed in loading (think projection into a tab pane)
    // and because we rely on a library that operates outside the Angular view of the world
    // we need to keep trying to load the library, until the relevant DOM is actually live
    ngAfterViewChecked() {
        if (!this.isFlatpickrLoaded()) {
            /// @ts-ignore ts is unhappy with the below call to `flatpickr`
            this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);
            // if (and only if) the initialization succeeded, we can set the date values
            if (this.isFlatpickrLoaded()) {
                if (this.value.length > 0) {
                    this.setDateValues(this.value);
                }
            }
        }
    }
    ngAfterContentInit() {
        languages.default.en.weekdays.shorthand
            = languages.default.en.weekdays.longhand.map(day => {
                if (day === "Thursday") {
                    return "Th";
                }
                return day.charAt(0);
            });
    }
    onFocus() {
        // Updates the month manually when calendar mode is range because month
        // will not update properly without manually updating them on focus.
        if (this.range) {
            if (this.rangeInput.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[1]) {
                const currentMonth = this.flatpickrInstance.selectedDates[1].getMonth();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
            else if (this.input.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[0]) {
                const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
        }
    }
    onFocusOut() {
        this.onTouched();
    }
    /**
     * Writes a value from the model to the component. Expects the value to be `null` or `(Date | string)[]`
     * @param value value received from the model
     */
    writeValue(value) {
        this.value = value;
        setTimeout(() => {
            if (this.isFlatpickrLoaded() && this.flatpickrInstance.config) {
                this.setDateValues(this.value);
            }
        });
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the DatePicker.
     *
     * ex: `this.formGroup.get("myDatePicker").disable();`
     *
     * @param isDisabled `true` to disable the DatePicker
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Cleans up our flatpickr instance
     */
    ngOnDestroy() {
        if (!this.isFlatpickrLoaded()) {
            return;
        }
        this.flatpickrInstance.destroy();
        this.visibilitySubscription.unsubscribe();
    }
    /**
     * Handles the `valueChange` event from the primary/single input
     */
    onValueChange(event) {
        if (this.isFlatpickrLoaded()) {
            const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
            if (this.range) {
                this.setDateValues([date, this.flatpickrInstance.selectedDates[1]]);
            }
            else {
                this.setDateValues([date]);
            }
            this.doSelect(this.flatpickrInstance.selectedDates);
        }
    }
    /**
     * Handles the `valueChange` event from the range input
     */
    onRangeValueChange(event) {
        if (this.isFlatpickrLoaded() && this.flatpickrInstance.isOpen) {
            const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
            this.setDateValues([this.flatpickrInstance.selectedDates[0], date]);
            this.doSelect(this.flatpickrInstance.selectedDates);
        }
    }
    /**
     * Handles opening the calendar "properly" when the calendar icon is clicked.
     */
    openCalendar(datepickerInput) {
        if (this.range) {
            datepickerInput.input.nativeElement.click();
            // If the first input's calendar icon is clicked when calendar is in range mode, then
            // the month and year needs to be manually changed to the current selected month and
            // year otherwise the calendar view will not be updated upon opening.
            if (datepickerInput === this.input && this.flatpickrInstance.selectedDates[0]) {
                const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
                this.flatpickrInstance.currentYear = this.flatpickrInstance.selectedDates[0].getFullYear();
                this.flatpickrInstance.changeMonth(currentMonth, false);
            }
        }
        else {
            // Single-mode flatpickr handles mousedown but not click, so nativeElement.click() won't
            // work when the calendar icon is clicked. In this case we simply use flatpickr.open().
            this.flatpickrInstance.open();
        }
    }
    updateCalendarListeners() {
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        Array.from(calendarContainer).forEach(calendar => {
            calendar.removeEventListener("click", this.preventCalendarClose);
            calendar.addEventListener("click", this.preventCalendarClose);
        });
    }
    /**
     * Handles the initialization of event listeners for the datepicker input and range input fields.
     */
    addInputListeners() {
        if (!this.isFlatpickrLoaded()) {
            return;
        }
        // Allows focus transition from the datepicker input or range input field to
        // flatpickr calendar using a keyboard.
        const addFocusCalendarListener = (element) => {
            element.addEventListener("keydown", (event) => {
                if (event.key === "ArrowDown") {
                    if (!this.flatpickrInstance.isOpen) {
                        this.flatpickrInstance.open();
                    }
                    const calendarContainer = this.flatpickrInstance.calendarContainer;
                    const dayElement = calendarContainer && calendarContainer.querySelector(".flatpickr-day[tabindex]");
                    if (dayElement) {
                        dayElement.focus();
                        // If the user manually inputs a value into the date field and presses arrow down,
                        // datepicker input onchange will be triggered when focus is removed from it and
                        // `flatpickrInstance.setDate` and `flatpickrInstance.changeMonth` will be invoked
                        // which will automatically change focus to the beginning of the document.
                        if (document.activeElement !== dayElement && this.flatpickrInstance.selectedDateElem) {
                            this.flatpickrInstance.selectedDateElem.focus();
                        }
                    }
                }
            });
        };
        if (this.input && this.input.input) {
            addFocusCalendarListener(this.input.input.nativeElement);
        }
        if (this.rangeInput && this.rangeInput.input) {
            addFocusCalendarListener(this.rangeInput.input.nativeElement);
        }
    }
    /**
     * Resets the flatpickr instance while keeping the date values (or updating them if newDates is provided)
     *
     * Used to pick up input changes or locale changes.
     *
     * @param newDates An optional SimpleChange of date values
     */
    resetFlatpickrInstance(newDates) {
        if (this.isFlatpickrLoaded()) {
            let dates = this.flatpickrInstance.selectedDates;
            if (newDates && this.didDateValueChange(newDates.currentValue, newDates.previousValue)) {
                dates = newDates.currentValue;
            }
            // only reset the flatpickr instance on Input changes
            this.flatpickrInstance = flatpickr(`#${this.id}-input`, this.flatpickrOptions);
            this.setDateValues(dates);
        }
    }
    /**
     * Carbon uses a number of specific classnames for parts of the flatpickr - this idempotent method applies them if needed.
     */
    updateClassNames() {
        if (!this.elementRef) {
            return;
        }
        // get all the possible flatpickrs in the document - we need to add classes to (potentially) all of them
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        const monthContainer = document.querySelectorAll(".flatpickr-month");
        const weekdaysContainer = document.querySelectorAll(".flatpickr-weekdays");
        const weekdayContainer = document.querySelectorAll(".flatpickr-weekday");
        const daysContainer = document.querySelectorAll(".flatpickr-days");
        const dayContainer = document.querySelectorAll(".flatpickr-day");
        // add classes to lists of elements
        const addClassIfNotExists = (classname, elementList) => {
            Array.from(elementList).forEach(element => {
                if (!element.classList.contains(classname)) {
                    element.classList.add(classname);
                }
            });
        };
        // add classes (but only if they don't exist, small perf win)
        addClassIfNotExists("bx--date-picker__calendar", calendarContainer);
        addClassIfNotExists("bx--date-picker__month", monthContainer);
        addClassIfNotExists("bx--date-picker__weekdays", weekdaysContainer);
        addClassIfNotExists("bx--date-picker__days", daysContainer);
        // add weekday classes and format the text
        Array.from(weekdayContainer).forEach(element => {
            element.innerHTML = element.innerHTML.replace(/\s+/g, "");
            element.classList.add("bx--date-picker__weekday");
        });
        // add day classes and special case the "today" element based on `this.value`
        Array.from(dayContainer).forEach(element => {
            element.classList.add("bx--date-picker__day");
            if (!this.value) {
                return;
            }
            if (element.classList.contains("today") && this.value.length > 0) {
                element.classList.add("no-border");
            }
            else if (element.classList.contains("today") && this.value.length === 0) {
                element.classList.remove("no-border");
            }
        });
    }
    updateAttributes() {
        const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
        Array.from(calendarContainer).forEach(calendar => {
            calendar.setAttribute("role", "region");
            calendar.setAttribute("aria-label", this.ariaLabel);
        });
    }
    /**
     * Applies the given date value array to both the flatpickr instance and the `input`(s)
     * @param dates the date values to apply
     */
    setDateValues(dates) {
        if (this.isFlatpickrLoaded()) {
            const singleInput = this.elementRef.nativeElement.querySelector(`#${this.id}-input`);
            const rangeInput = this.elementRef.nativeElement.querySelector(`#${this.id}-rangeInput`);
            // `flatpickrInstance.setDate` removes the focus on the selected date element and will
            // automatically change focus to the beginning of the document. If a selected date is
            // focused before `flatpickrInstance.setDate` is invoked then it should remain focused.
            let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
            // set the date on the instance
            this.flatpickrInstance.setDate(dates);
            if (shouldRefocusDateElement) {
                this.flatpickrInstance.selectedDateElem.focus();
            }
            // we can either set a date value or an empty string, so we start with an empty string
            let singleDate = "";
            // if date is a string, parse and format
            if (typeof this.flatpickrInstance.selectedDates[0] === "string") {
                singleDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
                singleDate = this.flatpickrInstance.formatDate(singleDate, this.dateFormat);
                // if date is not a string we can assume it's a Date and we should format
            }
            else if (!!this.flatpickrInstance.selectedDates[0]) {
                singleDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
            }
            if (rangeInput) {
                // we can either set a date value or an empty string, so we start with an empty string
                let rangeDate = "";
                // if date is a string, parse and format
                if (typeof this.flatpickrInstance.selectedDates[1] === "string") {
                    rangeDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[1].toString(), this.dateFormat);
                    rangeDate = this.flatpickrInstance.formatDate(rangeDate, this.dateFormat);
                    // if date is not a string we can assume it's a Date and we should format
                }
                else if (!!this.flatpickrInstance.selectedDates[1]) {
                    rangeDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[1], this.dateFormat);
                }
                setTimeout(() => {
                    // apply the values
                    rangeInput.value = rangeDate;
                    singleInput.value = singleDate;
                });
            }
        }
    }
    doSelect(selectedValue) {
        // In range mode, if a date is selected from the first calendar that is from the previous month,
        // the month will not be updated on the calendar until the calendar is re-opened.
        // This will make sure the calendar is updated with the correct month.
        if (this.range && this.flatpickrInstance.selectedDates[0]) {
            const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
            // `flatpickrInstance.changeMonth` removes the focus on the selected date element and will
            // automatically change focus to the beginning of the document. If a selected date is
            // focused before `flatpickrInstance.changeMonth` is invoked then it should remain focused.
            let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
            this.flatpickrInstance.changeMonth(currentMonth, false);
            if (shouldRefocusDateElement) {
                this.flatpickrInstance.selectedDateElem.focus();
            }
        }
        this.valueChange.emit(selectedValue);
        this.propagateChange(selectedValue);
    }
    didDateValueChange(currentValue, previousValue) {
        return currentValue[0] !== previousValue[0] || currentValue[1] !== previousValue[1];
    }
    /**
     * More advanced checking of the loaded state of flatpickr
     */
    isFlatpickrLoaded() {
        // cast the instance to a boolean, and some method that has to exist for the library to be loaded in this case `setDate`
        return !!this.flatpickrInstance && !!this.flatpickrInstance.setDate;
    }
    /**
     * Right arrow HTML passed to flatpickr
     */
    rightArrowHTML() {
        return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
    }
    /**
     * Left arrow HTML passed to flatpickr
     */
    leftArrowHTML() {
        return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
    }
}
DatePicker.datePickerCount = 0;
DatePicker.decorators = [
    { type: Component, args: [{
                selector: "ibm-date-picker",
                template: `
	<div class="bx--form-item">
		<div
			class="bx--date-picker"
			[ngClass]="{
				'bx--date-picker--range' : range,
				'bx--date-picker--single' : !range,
				'bx--date-picker--light' : theme === 'light',
				'bx--skeleton' : skeleton
			}">
			<div class="bx--date-picker-container">
				<ibm-date-picker-input
					#input
					[label]="label"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-input'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? false : true)"
					[disabled]="disabled"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[skeleton]="skeleton"
					(valueChange)="onValueChange($event)"
					(click)="openCalendar(input)">
				</ibm-date-picker-input>
			</div>

			<div *ngIf="range" class="bx--date-picker-container">
				<ibm-date-picker-input
					#rangeInput
					[label]="rangeLabel"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-rangeInput'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? true : null)"
					[disabled]="disabled"
					[invalid]="rangeInvalid"
					[invalidText]="rangeInvalidText"
					[warn]="rangeWarn"
					[warnText]="rangeWarnText"
					[skeleton]="skeleton"
					(valueChange)="onRangeValueChange($event)"
					(click)="openCalendar(rangeInput)">
				</ibm-date-picker-input>
			</div>
		</div>
	</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: DatePicker,
                        multi: true
                    }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [`.dayContainer {
			justify-content: initial;
		}`]
            }] }
];
/** @nocollapse */
DatePicker.ctorParameters = () => [
    { type: ElementRef },
    { type: ElementService },
    { type: I18n }
];
DatePicker.propDecorators = {
    range: [{ type: Input }],
    dateFormat: [{ type: Input }],
    language: [{ type: Input }],
    label: [{ type: Input }],
    rangeLabel: [{ type: Input }],
    placeholder: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    pattern: [{ type: Input }],
    inputPattern: [{ type: Input }],
    id: [{ type: Input }],
    value: [{ type: Input }],
    theme: [{ type: Input }],
    disabled: [{ type: Input }],
    invalid: [{ type: Input }],
    invalidText: [{ type: Input }],
    warn: [{ type: Input }],
    warnText: [{ type: Input }],
    size: [{ type: Input }],
    rangeInvalid: [{ type: Input }],
    rangeInvalidText: [{ type: Input }],
    rangeWarn: [{ type: Input }],
    rangeWarnText: [{ type: Input }],
    skeleton: [{ type: Input }],
    plugins: [{ type: Input }],
    flatpickrOptions: [{ type: Input }],
    input: [{ type: ViewChild, args: ["input", { static: true },] }],
    rangeInput: [{ type: ViewChild, args: ["rangeInput", { static: false },] }],
    valueChange: [{ type: Output }],
    onFocus: [{ type: HostListener, args: ["focusin",] }],
    onFocusOut: [{ type: HostListener, args: ["focusout",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2RhdGVwaWNrZXIvIiwic291cmNlcyI6WyJkYXRlcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLGlCQUFpQixFQUNqQixVQUFVLEVBRVYsWUFBWSxFQU1aLFNBQVMsRUFJVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLFdBQVcsTUFBTSxvQ0FBb0MsQ0FBQztBQUM3RCxPQUFPLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDbkYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwQyxPQUFPLEtBQUssU0FBUyxNQUFNLDJCQUEyQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSw0Q0FBNEMsQ0FBQztBQUM3RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDakUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXREOzs7O0dBSUc7QUF1RUgsTUFBTSxPQUFPLFVBQVU7SUF3THRCLFlBQ1csVUFBc0IsRUFDdEIsY0FBOEIsRUFDOUIsSUFBVTtRQUZWLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLFNBQUksR0FBSixJQUFJLENBQU07UUFsTHJCOztXQUVHO1FBQ00sVUFBSyxHQUFHLEtBQUssQ0FBQztRQUV2Qjs7OztXQUlHO1FBQ00sZUFBVSxHQUFHLE9BQU8sQ0FBQztRQUU5Qjs7Ozs7V0FLRztRQUNNLGFBQVEsR0FB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RSxpQkFBaUIsQ0FBQyxJQUFJO3lCQVhwQzs7SUFFRTthQVVIOzs7O1lBakdBLFVBQVU7WUFvQkYsY0FBYztZQUNkLElBQUk7OztvQkF5RlgsS0FBSzt5QkFPTCxLQUFLO3VCQVFMLEtBQUs7b0JBRUwsS0FBSzt5QkFFTCxLQUFLOzBCQUVMLEtBQUs7d0JBS0wsS0FBSztzQkFNTCxLQUFLOzJCQUtMLEtBQUs7aUJBUUwsS0FBSztvQkFFTCxLQUFLO29CQVdMLEtBQUs7dUJBRUwsS0FBSztzQkFJTCxLQUFLOzBCQUlMLEtBQUs7bUJBSUwsS0FBSzt1QkFJTCxLQUFLO21CQUVMLEtBQUs7MkJBSUwsS0FBSzsrQkFJTCxLQUFLO3dCQUlMLEtBQUs7NEJBSUwsS0FBSzt1QkFFTCxLQUFLO3NCQUVMLEtBQUs7K0JBRUwsS0FBSztvQkFrQkwsU0FBUyxTQUFDLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7eUJBR25DLFNBQVMsU0FBQyxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFOzBCQUV6QyxNQUFNO3NCQThITixZQUFZLFNBQUMsU0FBUzt5QkFldEIsWUFBWSxTQUFDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0Vmlld0VuY2Fwc3VsYXRpb24sXG5cdEVsZW1lbnRSZWYsXG5cdE9uRGVzdHJveSxcblx0SG9zdExpc3RlbmVyLFxuXHRUZW1wbGF0ZVJlZixcblx0T25DaGFuZ2VzLFxuXHRTaW1wbGVDaGFuZ2VzLFxuXHRBZnRlclZpZXdDaGVja2VkLFxuXHRBZnRlclZpZXdJbml0LFxuXHRWaWV3Q2hpbGQsXG5cdEFmdGVyQ29udGVudEluaXQsXG5cdE9uSW5pdCxcblx0U2ltcGxlQ2hhbmdlXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgcmFuZ2VQbHVnaW4gZnJvbSBcImZsYXRwaWNrci9kaXN0L3BsdWdpbnMvcmFuZ2VQbHVnaW5cIjtcbmltcG9ydCBmbGF0cGlja3IgZnJvbSBcImZsYXRwaWNrclwiO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IGNhcmJvbkZsYXRwaWNrck1vbnRoU2VsZWN0UGx1Z2luIH0gZnJvbSBcIi4vY2FyYm9uLWZsYXRwaWNrci1tb250aC1zZWxlY3RcIjtcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgKiBhcyBsYW5ndWFnZXMgZnJvbSBcImZsYXRwaWNrci9kaXN0L2wxMG4vaW5kZXhcIjtcbmltcG9ydCB7IERhdGVQaWNrZXJJbnB1dCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2RhdGVwaWNrZXItaW5wdXRcIjtcbmltcG9ydCB7IEVsZW1lbnRTZXJ2aWNlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcbmltcG9ydCB7IEkxOG4gfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5cbi8qKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1kYXRlLXBpY2tlci0tc2luZ2xlKVxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD1jb21wb25lbnRzLWRhdGUtcGlja2VyLS1zaW5nbGU8L2V4YW1wbGUtdXJsPlxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiaWJtLWRhdGUtcGlja2VyXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDxkaXYgY2xhc3M9XCJieC0tZm9ybS1pdGVtXCI+XG5cdFx0PGRpdlxuXHRcdFx0Y2xhc3M9XCJieC0tZGF0ZS1waWNrZXJcIlxuXHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHQnYngtLWRhdGUtcGlja2VyLS1yYW5nZScgOiByYW5nZSxcblx0XHRcdFx0J2J4LS1kYXRlLXBpY2tlci0tc2luZ2xlJyA6ICFyYW5nZSxcblx0XHRcdFx0J2J4LS1kYXRlLXBpY2tlci0tbGlnaHQnIDogdGhlbWUgPT09ICdsaWdodCcsXG5cdFx0XHRcdCdieC0tc2tlbGV0b24nIDogc2tlbGV0b25cblx0XHRcdH1cIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tZGF0ZS1waWNrZXItY29udGFpbmVyXCI+XG5cdFx0XHRcdDxpYm0tZGF0ZS1waWNrZXItaW5wdXRcblx0XHRcdFx0XHQjaW5wdXRcblx0XHRcdFx0XHRbbGFiZWxdPVwibGFiZWxcIlxuXHRcdFx0XHRcdFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG5cdFx0XHRcdFx0W3BhdHRlcm5dPVwiaW5wdXRQYXR0ZXJuXCJcblx0XHRcdFx0XHRbaWRdPVwiaWQgKyAnLWlucHV0J1wiXG5cdFx0XHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRcdFx0W3R5cGVdPVwiKHJhbmdlID8gJ3JhbmdlJyA6ICdzaW5nbGUnKVwiXG5cdFx0XHRcdFx0W2hhc0ljb25dPVwiKHJhbmdlID8gZmFsc2UgOiB0cnVlKVwiXG5cdFx0XHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFx0XHRbaW52YWxpZF09XCJpbnZhbGlkXCJcblx0XHRcdFx0XHRbaW52YWxpZFRleHRdPVwiaW52YWxpZFRleHRcIlxuXHRcdFx0XHRcdFt3YXJuXT1cIndhcm5cIlxuXHRcdFx0XHRcdFt3YXJuVGV4dF09XCJ3YXJuVGV4dFwiXG5cdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0XHQodmFsdWVDaGFuZ2UpPVwib25WYWx1ZUNoYW5nZSgkZXZlbnQpXCJcblx0XHRcdFx0XHQoY2xpY2spPVwib3BlbkNhbGVuZGFyKGlucHV0KVwiPlxuXHRcdFx0XHQ8L2libS1kYXRlLXBpY2tlci1pbnB1dD5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2ICpuZ0lmPVwicmFuZ2VcIiBjbGFzcz1cImJ4LS1kYXRlLXBpY2tlci1jb250YWluZXJcIj5cblx0XHRcdFx0PGlibS1kYXRlLXBpY2tlci1pbnB1dFxuXHRcdFx0XHRcdCNyYW5nZUlucHV0XG5cdFx0XHRcdFx0W2xhYmVsXT1cInJhbmdlTGFiZWxcIlxuXHRcdFx0XHRcdFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG5cdFx0XHRcdFx0W3BhdHRlcm5dPVwiaW5wdXRQYXR0ZXJuXCJcblx0XHRcdFx0XHRbaWRdPVwiaWQgKyAnLXJhbmdlSW5wdXQnXCJcblx0XHRcdFx0XHRbc2l6ZV09XCJzaXplXCJcblx0XHRcdFx0XHRbdHlwZV09XCIocmFuZ2UgPyAncmFuZ2UnIDogJ3NpbmdsZScpXCJcblx0XHRcdFx0XHRbaGFzSWNvbl09XCIocmFuZ2UgPyB0cnVlIDogbnVsbClcIlxuXHRcdFx0XHRcdFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG5cdFx0XHRcdFx0W2ludmFsaWRdPVwicmFuZ2VJbnZhbGlkXCJcblx0XHRcdFx0XHRbaW52YWxpZFRleHRdPVwicmFuZ2VJbnZhbGlkVGV4dFwiXG5cdFx0XHRcdFx0W3dhcm5dPVwicmFuZ2VXYXJuXCJcblx0XHRcdFx0XHRbd2FyblRleHRdPVwicmFuZ2VXYXJuVGV4dFwiXG5cdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0XHQodmFsdWVDaGFuZ2UpPVwib25SYW5nZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuXHRcdFx0XHRcdChjbGljayk9XCJvcGVuQ2FsZW5kYXIocmFuZ2VJbnB1dClcIj5cblx0XHRcdFx0PC9pYm0tZGF0ZS1waWNrZXItaW5wdXQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cdGAsXG5cdHN0eWxlczogW1xuXHRcdGAuZGF5Q29udGFpbmVyIHtcblx0XHRcdGp1c3RpZnktY29udGVudDogaW5pdGlhbDtcblx0XHR9YFxuXHRdLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBEYXRlUGlja2VyLFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF0sXG5cdGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpY2tlciBpbXBsZW1lbnRzXG5cdE9uSW5pdCxcblx0T25EZXN0cm95LFxuXHRPbkNoYW5nZXMsXG5cdEFmdGVyVmlld0NoZWNrZWQsXG5cdEFmdGVyVmlld0luaXQsXG5cdEFmdGVyQ29udGVudEluaXQge1xuXHRwcml2YXRlIHN0YXRpYyBkYXRlUGlja2VyQ291bnQgPSAwO1xuXG5cdC8qKlxuXHQgKiBTZWxlY3QgY2FsZW5kYXIgcmFuZ2UgbW9kZVxuXHQgKi9cblx0QElucHV0KCkgcmFuZ2UgPSBmYWxzZTtcblxuXHQvKipcblx0ICogRm9ybWF0IG9mIGRhdGVcblx0ICpcblx0ICogRm9yIHJlZmVyZW5jZTogaHR0cHM6Ly9mbGF0cGlja3IuanMub3JnL2Zvcm1hdHRpbmcvXG5cdCAqL1xuXHRASW5wdXQoKSBkYXRlRm9ybWF0ID0gXCJtL2QvWVwiO1xuXG5cdC8qKlxuXHQgKiBMYW5ndWFnZSBvZiB0aGUgZmxhdHBpY2tyIGNhbGVuZGFyLlxuXHQgKlxuXHQgKiBGb3IgcmVmZXJlbmNlIG9mIHRoZSBwb3NzaWJsZSBsb2NhbGVzOlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vZmxhdHBpY2tyL2ZsYXRwaWNrci9ibG9iL21hc3Rlci9zcmMvbDEwbi9pbmRleC50c1xuXHQgKi9cblx0QElucHV0KCkgbGFuZ3VhZ2UgPSBcImVuXCI7XG5cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyAgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cdEBJbnB1dCgpIHJhbmdlTGFiZWw6IHN0cmluZztcblxuXHRASW5wdXQoKSBwbGFjZWhvbGRlciA9IFwibW0vZGQveXl5eVwiO1xuXG5cdC8qKlxuXHQgKiBBcmlhIGxhYmVsIGFkZGVkIHRvIGRhdGVwaWNrZXIncyBjYWxlbmRhciBjb250YWluZXIuXG5cdCAqL1xuXHRASW5wdXQoKSBhcmlhTGFiZWwgPSBcImNhbGVuZGFyIGNvbnRhaW5lclwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcGF0dGVybiBmb3IgdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudFxuXHQgKiBAZGVwcmVjYXRlZCBhcyBvZiB2NCAtIHN3aXRjaCB0byBpbnB1dFBhdHRlcm5cblx0ICovXG5cdEBJbnB1dCgpIHBhdHRlcm4gPSBcIl5cXFxcZHsxLDJ9L1xcXFxkezEsMn0vXFxcXGR7NH0kXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwYXR0ZXJuIGZvciB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50XG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgaW5wdXRQYXR0ZXJuKHZhbHVlOiBzdHJpbmcpIHtcblx0XHR0aGlzLnBhdHRlcm4gPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBpbnB1dFBhdHRlcm4oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGF0dGVybjtcblx0fVxuXG5cdEBJbnB1dCgpIGlkID0gYGRhdGVwaWNrZXItJHtEYXRlUGlja2VyLmRhdGVQaWNrZXJDb3VudCsrfWA7XG5cblx0QElucHV0KCkgc2V0IHZhbHVlKHY6IChEYXRlIHwgc3RyaW5nKVtdKSB7XG5cdFx0aWYgKCF2KSB7XG5cdFx0XHR2ID0gW107XG5cdFx0fVxuXHRcdHRoaXMuX3ZhbHVlID0gdjtcblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKSB0aGVtZTogXCJsaWdodFwiIHwgXCJkYXJrXCIgPSBcImRhcmtcIjtcblxuXHRASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBkaXNwbGF5IHRoZSBpbnZhbGlkIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgaW52YWxpZCA9IGZhbHNlO1xuXHQvKipcblx0ICogVmFsdWUgZGlzcGxheWVkIGlmIGRhdGVwaWNrZXIgaXMgaW4gYW4gaW52YWxpZCBzdGF0ZS5cblx0ICovXG5cdEBJbnB1dCgpIGludmFsaWRUZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKipcblx0ICAqIFNldCB0byBgdHJ1ZWAgdG8gc2hvdyBhIHdhcm5pbmcgKGNvbnRlbnRzIHNldCBieSB3YXJuaW5nVGV4dClcblx0ICAqL1xuXHRASW5wdXQoKSB3YXJuID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB3YXJuaW5nIHRleHRcblx0ICovXG5cdEBJbnB1dCgpIHdhcm5UZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cdEBJbnB1dCgpIHNpemU6IFwic21cIiB8IFwibWRcIiB8IFwieGxcIiA9IFwibWRcIjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzcGxheSB0aGUgaW52YWxpZCBzdGF0ZSBmb3IgdGhlIHNlY29uZCBkYXRlcGlja2VyIGlucHV0LlxuXHQgKi9cblx0QElucHV0KCkgcmFuZ2VJbnZhbGlkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBWYWx1ZSBkaXNwbGF5ZWQgaWYgdGhlIHNlY29uZCBkYXRlcGlja2VyIGlucHV0IGlzIGluIGFuIGludmFsaWQgc3RhdGUuXG5cdCAqL1xuXHRASW5wdXQoKSByYW5nZUludmFsaWRUZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKipcblx0ICAqIFNldCB0byBgdHJ1ZWAgdG8gc2hvdyBhIHdhcm5pbmcgaW4gdGhlIHNlY29uZCBkYXRlcGlja2VyIGlucHV0IChjb250ZW50cyBzZXQgYnkgcmFuZ2VXYXJuaW5nVGV4dClcblx0ICAqL1xuXHRASW5wdXQoKSByYW5nZVdhcm4gPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldHMgdGhlIHdhcm5pbmcgdGV4dCBmb3IgdGhlIHNlY29uZCBkYXRlcGlja2VyIGlucHV0XG5cdCAqL1xuXHRASW5wdXQoKSByYW5nZVdhcm5UZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0QElucHV0KCkgcGx1Z2lucyA9IFtdO1xuXG5cdEBJbnB1dCgpXG5cdHNldCBmbGF0cGlja3JPcHRpb25zKG9wdGlvbnMpIHtcblx0XHR0aGlzLl9mbGF0cGlja3JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucywgb3B0aW9ucyk7XG5cdH1cblx0Z2V0IGZsYXRwaWNrck9wdGlvbnMoKSB7XG5cdFx0Y29uc3QgcGx1Z2lucyA9IFsuLi50aGlzLnBsdWdpbnMsIGNhcmJvbkZsYXRwaWNrck1vbnRoU2VsZWN0UGx1Z2luXTtcblx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0cGx1Z2lucy5wdXNoKHJhbmdlUGx1Z2luKHsgaW5wdXQ6IGAjJHt0aGlzLmlkfS1yYW5nZUlucHV0YCwgcG9zaXRpb246IFwibGVmdFwifSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZmxhdHBpY2tyT3B0aW9ucywgdGhpcy5mbGF0cGlja3JCYXNlT3B0aW9ucywge1xuXHRcdFx0bW9kZTogdGhpcy5yYW5nZSA/IFwicmFuZ2VcIiA6IFwic2luZ2xlXCIsXG5cdFx0XHRwbHVnaW5zLFxuXHRcdFx0ZGF0ZUZvcm1hdDogdGhpcy5kYXRlRm9ybWF0LFxuXHRcdFx0bG9jYWxlOiBsYW5ndWFnZXMuZGVmYXVsdFt0aGlzLmxhbmd1YWdlXVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRAVmlld0NoaWxkKFwiaW5wdXRcIiwgeyBzdGF0aWM6IHRydWUgfSkgaW5wdXQ6IERhdGVQaWNrZXJJbnB1dDtcblxuXHQvLyBAdHMtaWdub3JlXG5cdEBWaWV3Q2hpbGQoXCJyYW5nZUlucHV0XCIsIHsgc3RhdGljOiBmYWxzZSB9KSByYW5nZUlucHV0OiBEYXRlUGlja2VySW5wdXQ7XG5cblx0QE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRwcm90ZWN0ZWQgX3ZhbHVlID0gW107XG5cblx0cHJvdGVjdGVkIF9mbGF0cGlja3JPcHRpb25zID0ge1xuXHRcdGFsbG93SW5wdXQ6IHRydWVcblx0fTtcblxuXHRwcm90ZWN0ZWQgZmxhdHBpY2tyQmFzZU9wdGlvbnMgPSB7XG5cdFx0bW9kZTogXCJzaW5nbGVcIixcblx0XHRkYXRlRm9ybWF0OiBcIm0vZC9ZXCIsXG5cdFx0cGx1Z2luczogdGhpcy5wbHVnaW5zLFxuXHRcdG9uT3BlbjogKCkgPT4ge1xuXHRcdFx0dGhpcy51cGRhdGVDbGFzc05hbWVzKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoKTtcblx0XHRcdHRoaXMudXBkYXRlQ2FsZW5kYXJMaXN0ZW5lcnMoKTtcblx0XHR9LFxuXHRcdG9uQ2xvc2U6ICgpID0+IHtcblx0XHRcdC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBgZmxhdHBpY2tySW5zdGFuY2Ugc2VsZWN0ZWREYXRlc2AgYXJlIGluIHN5bmMgd2l0aCB0aGUgdmFsdWVzIG9mXG5cdFx0XHQvLyB0aGUgaW5wdXRzIHdoZW4gdGhlIGNhbGVuZGFyIGNsb3Nlcy5cblx0XHRcdGlmICh0aGlzLnJhbmdlICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UpIHtcblx0XHRcdFx0aWYgKHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlcy5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0XHQvLyB3ZSBjb3VsZCBgdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jbGVhcigpYCBidXQgaXQgaW5zaXN0cyBvbiBvcGVuaW5nIHRoZSBzZWNvbmQgcGlja2VyXG5cdFx0XHRcdFx0Ly8gaW4gc29tZSBjYXNlcywgc28gaW5zdGVhZCB3ZSBkbyB0aGlzXG5cdFx0XHRcdFx0dGhpcy5zZXREYXRlVmFsdWVzKFtdKTtcblx0XHRcdFx0XHR0aGlzLmRvU2VsZWN0KFtdKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgaW5wdXRWYWx1ZSA9IHRoaXMuaW5wdXQuaW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZTtcblx0XHRcdFx0Y29uc3QgcmFuZ2VJbnB1dFZhbHVlID0gdGhpcy5yYW5nZUlucHV0LmlucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG5cdFx0XHRcdGlmIChpbnB1dFZhbHVlIHx8IHJhbmdlSW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlOiBzdHJpbmcpID0+IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UucGFyc2VEYXRlKGRhdGUsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHRcdFx0dGhpcy5zZXREYXRlVmFsdWVzKFtwYXJzZURhdGUoaW5wdXRWYWx1ZSksIHBhcnNlRGF0ZShyYW5nZUlucHV0VmFsdWUpXSk7XG5cdFx0XHRcdFx0dGhpcy5kb1NlbGVjdCh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbkRheUNyZWF0ZTogKF9kT2JqLCBfZFN0ciwgX2ZwLCBkYXlFbGVtKSA9PiB7XG5cdFx0XHRkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJieC0tZGF0ZS1waWNrZXJfX2RheVwiKTtcblx0XHR9LFxuXHRcdG5leHRBcnJvdzogdGhpcy5yaWdodEFycm93SFRNTCgpLFxuXHRcdHByZXZBcnJvdzogdGhpcy5sZWZ0QXJyb3dIVE1MKCksXG5cdFx0dmFsdWU6IHRoaXMudmFsdWVcblx0fTtcblxuXHRwcm90ZWN0ZWQgZmxhdHBpY2tySW5zdGFuY2UgPSBudWxsO1xuXG5cdHByb3RlY3RlZCB2aXNpYmlsaXR5U3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuXHRcdHByb3RlY3RlZCBlbGVtZW50U2VydmljZTogRWxlbWVudFNlcnZpY2UsXG5cdFx0cHJvdGVjdGVkIGkxOG46IEkxOG5cblx0KSB7IH1cblxuXHRuZ09uSW5pdCgpIHtcblx0XHQvLyBpZiBpMThuIGlzIHNldCB0byBhbnl0aGluZyBvdGhlciB0aGFuIGVuIHdlJ2xsIHdhbnQgdG8gY2hhbmdlIHRoZSBsYW5ndWFnZVxuXHRcdC8vIG90aGVyd2lzZSB3ZSdsbCBqdXN0IHVzZSB0aGUgbG9jYWwgc2V0dGluZ1xuXHRcdGlmICh0aGlzLmkxOG4uZ2V0TG9jYWxlKCkgIT09IFwiZW5cIikge1xuXHRcdFx0dGhpcy5pMThuLmdldExvY2FsZU9ic2VydmFibGUoKS5zdWJzY3JpYmUobG9jYWxlID0+IHtcblx0XHRcdFx0dGhpcy5sYW5ndWFnZSA9IGxvY2FsZTtcblx0XHRcdFx0dGhpcy5yZXNldEZsYXRwaWNrckluc3RhbmNlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG5cdFx0Ly8gUmVzZXQgdGhlIGZsYXRwaWNrciBpbnN0YW5jZSBvbiBpbnB1dCBjaGFuZ2VzIHRoYXQgYWZmZWN0IGZsYXRwaWNrci5cblx0XHRjb25zdCBmbGF0cGlja3JDaGFuZ2VLZXlzID0gW1xuXHRcdFx0XCJyYW5nZVwiLFxuXHRcdFx0XCJkYXRlRm9ybWF0XCIsXG5cdFx0XHRcImxhbmd1YWdlXCIsXG5cdFx0XHRcImlkXCIsXG5cdFx0XHRcInZhbHVlXCIsXG5cdFx0XHRcInBsdWdpbnNcIixcblx0XHRcdFwiZmxhdHBpY2tyT3B0aW9uc1wiXG5cdFx0XTtcblx0XHRjb25zdCBjaGFuZ2VLZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG5cdFx0aWYgKGNoYW5nZUtleXMuc29tZShrZXkgPT4gZmxhdHBpY2tyQ2hhbmdlS2V5cy5pbmNsdWRlcyhrZXkpKSkge1xuXHRcdFx0dGhpcy5yZXNldEZsYXRwaWNrckluc3RhbmNlKGNoYW5nZXMudmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHR0aGlzLnZpc2liaWxpdHlTdWJzY3JpcHRpb24gPSB0aGlzLmVsZW1lbnRTZXJ2aWNlXG5cdFx0XHQudmlzaWJpbGl0eSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpXG5cdFx0XHQuc3Vic2NyaWJlKHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKHRoaXMuaXNGbGF0cGlja3JMb2FkZWQoKSAmJiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmlzT3Blbikge1xuXHRcdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuX3Bvc2l0aW9uQ2FsZW5kYXIodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5pZH0taW5wdXRgKSk7XG5cdFx0XHRcdFx0aWYgKCF2YWx1ZS52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLmNsb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5hZGRJbnB1dExpc3RlbmVycygpO1xuXHRcdH0sIDApO1xuXHR9XG5cblx0Ly8gYmVjYXVzZSB0aGUgYWN0dWFsIHZpZXcgbWF5IGJlIGRlbGF5ZWQgaW4gbG9hZGluZyAodGhpbmsgcHJvamVjdGlvbiBpbnRvIGEgdGFiIHBhbmUpXG5cdC8vIGFuZCBiZWNhdXNlIHdlIHJlbHkgb24gYSBsaWJyYXJ5IHRoYXQgb3BlcmF0ZXMgb3V0c2lkZSB0aGUgQW5ndWxhciB2aWV3IG9mIHRoZSB3b3JsZFxuXHQvLyB3ZSBuZWVkIHRvIGtlZXAgdHJ5aW5nIHRvIGxvYWQgdGhlIGxpYnJhcnksIHVudGlsIHRoZSByZWxldmFudCBET00gaXMgYWN0dWFsbHkgbGl2ZVxuXHRuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRmxhdHBpY2tyTG9hZGVkKCkpIHtcblx0XHRcdC8vLyBAdHMtaWdub3JlIHRzIGlzIHVuaGFwcHkgd2l0aCB0aGUgYmVsb3cgY2FsbCB0byBgZmxhdHBpY2tyYFxuXHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZSA9IGZsYXRwaWNrcihgIyR7dGhpcy5pZH0taW5wdXRgLCB0aGlzLmZsYXRwaWNrck9wdGlvbnMpO1xuXHRcdFx0Ly8gaWYgKGFuZCBvbmx5IGlmKSB0aGUgaW5pdGlhbGl6YXRpb24gc3VjY2VlZGVkLCB3ZSBjYW4gc2V0IHRoZSBkYXRlIHZhbHVlc1xuXHRcdFx0aWYgKHRoaXMuaXNGbGF0cGlja3JMb2FkZWQoKSkge1xuXHRcdFx0XHRpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXREYXRlVmFsdWVzKHRoaXMudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bmdBZnRlckNvbnRlbnRJbml0KCkge1xuXHRcdChsYW5ndWFnZXMuZGVmYXVsdC5lbi53ZWVrZGF5cy5zaG9ydGhhbmQgYXMgc3RyaW5nW10pXG5cdFx0XHQ9IGxhbmd1YWdlcy5kZWZhdWx0LmVuLndlZWtkYXlzLmxvbmdoYW5kLm1hcChkYXkgPT4ge1xuXHRcdFx0XHRpZiAoZGF5ID09PSBcIlRodXJzZGF5XCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJUaFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkYXkuY2hhckF0KDApO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwiZm9jdXNpblwiKVxuXHRvbkZvY3VzKCkge1xuXHRcdC8vIFVwZGF0ZXMgdGhlIG1vbnRoIG1hbnVhbGx5IHdoZW4gY2FsZW5kYXIgbW9kZSBpcyByYW5nZSBiZWNhdXNlIG1vbnRoXG5cdFx0Ly8gd2lsbCBub3QgdXBkYXRlIHByb3Blcmx5IHdpdGhvdXQgbWFudWFsbHkgdXBkYXRpbmcgdGhlbSBvbiBmb2N1cy5cblx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0aWYgKHRoaXMucmFuZ2VJbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0uZ2V0TW9udGgoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0TW9udGgoKTtcblx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRASG9zdExpc3RlbmVyKFwiZm9jdXNvdXRcIilcblx0b25Gb2N1c091dCgpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHZhbHVlIGZyb20gdGhlIG1vZGVsIHRvIHRoZSBjb21wb25lbnQuIEV4cGVjdHMgdGhlIHZhbHVlIHRvIGJlIGBudWxsYCBvciBgKERhdGUgfCBzdHJpbmcpW11gXG5cdCAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSByZWNlaXZlZCBmcm9tIHRoZSBtb2RlbFxuXHQgKi9cblx0d3JpdGVWYWx1ZSh2YWx1ZTogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuc2V0RGF0ZVZhbHVlcyh0aGlzLnZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIG1ldGhvZCB0byBwcm9ncmFtbWF0aWNhbGx5IGRpc2FibGUgdGhlIERhdGVQaWNrZXIuXG5cdCAqXG5cdCAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlEYXRlUGlja2VyXCIpLmRpc2FibGUoKTtgXG5cdCAqXG5cdCAqIEBwYXJhbSBpc0Rpc2FibGVkIGB0cnVlYCB0byBkaXNhYmxlIHRoZSBEYXRlUGlja2VyXG5cdCAqL1xuXHRzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcblx0XHR0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0fVxuXG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWQgPSBmbjtcblx0fVxuXG5cdG9uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4ge307XG5cblx0cHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4ge307XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBvdXIgZmxhdHBpY2tyIGluc3RhbmNlXG5cdCAqL1xuXHRuZ09uRGVzdHJveSgpIHtcblx0XHRpZiAoIXRoaXMuaXNGbGF0cGlja3JMb2FkZWQoKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLmRlc3Ryb3koKTtcblx0XHR0aGlzLnZpc2liaWxpdHlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBgdmFsdWVDaGFuZ2VgIGV2ZW50IGZyb20gdGhlIHByaW1hcnkvc2luZ2xlIGlucHV0XG5cdCAqL1xuXHRvblZhbHVlQ2hhbmdlKGV2ZW50OiBzdHJpbmcpIHtcblx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRjb25zdCBkYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5wYXJzZURhdGUoZXZlbnQsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cdFx0XHRpZiAodGhpcy5yYW5nZSkge1xuXHRcdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoW2RhdGUsIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1sxXV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXREYXRlVmFsdWVzKFtkYXRlXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvU2VsZWN0KHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGB2YWx1ZUNoYW5nZWAgZXZlbnQgZnJvbSB0aGUgcmFuZ2UgaW5wdXRcblx0ICovXG5cdG9uUmFuZ2VWYWx1ZUNoYW5nZShldmVudDogc3RyaW5nKSB7XG5cdFx0aWYgKHRoaXMuaXNGbGF0cGlja3JMb2FkZWQoKSAmJiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmlzT3Blbikge1xuXHRcdFx0Y29uc3QgZGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UucGFyc2VEYXRlKGV2ZW50LCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0dGhpcy5zZXREYXRlVmFsdWVzKFt0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0sIGRhdGVdKTtcblx0XHRcdHRoaXMuZG9TZWxlY3QodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBvcGVuaW5nIHRoZSBjYWxlbmRhciBcInByb3Blcmx5XCIgd2hlbiB0aGUgY2FsZW5kYXIgaWNvbiBpcyBjbGlja2VkLlxuXHQgKi9cblx0b3BlbkNhbGVuZGFyKGRhdGVwaWNrZXJJbnB1dDogRGF0ZVBpY2tlcklucHV0KSB7XG5cdFx0aWYgKHRoaXMucmFuZ2UpIHtcblx0XHRcdGRhdGVwaWNrZXJJbnB1dC5pbnB1dC5uYXRpdmVFbGVtZW50LmNsaWNrKCk7XG5cblx0XHRcdC8vIElmIHRoZSBmaXJzdCBpbnB1dCdzIGNhbGVuZGFyIGljb24gaXMgY2xpY2tlZCB3aGVuIGNhbGVuZGFyIGlzIGluIHJhbmdlIG1vZGUsIHRoZW5cblx0XHRcdC8vIHRoZSBtb250aCBhbmQgeWVhciBuZWVkcyB0byBiZSBtYW51YWxseSBjaGFuZ2VkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGVkIG1vbnRoIGFuZFxuXHRcdFx0Ly8geWVhciBvdGhlcndpc2UgdGhlIGNhbGVuZGFyIHZpZXcgd2lsbCBub3QgYmUgdXBkYXRlZCB1cG9uIG9wZW5pbmcuXG5cdFx0XHRpZiAoZGF0ZXBpY2tlcklucHV0ID09PSB0aGlzLmlucHV0ICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50TW9udGggPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0TW9udGgoKTtcblxuXHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLmN1cnJlbnRZZWFyID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuY2hhbmdlTW9udGgoY3VycmVudE1vbnRoLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFNpbmdsZS1tb2RlIGZsYXRwaWNrciBoYW5kbGVzIG1vdXNlZG93biBidXQgbm90IGNsaWNrLCBzbyBuYXRpdmVFbGVtZW50LmNsaWNrKCkgd29uJ3Rcblx0XHRcdC8vIHdvcmsgd2hlbiB0aGUgY2FsZW5kYXIgaWNvbiBpcyBjbGlja2VkLiBJbiB0aGlzIGNhc2Ugd2Ugc2ltcGx5IHVzZSBmbGF0cGlja3Iub3BlbigpLlxuXHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5vcGVuKCk7XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIHVwZGF0ZUNhbGVuZGFyTGlzdGVuZXJzKCkge1xuXHRcdGNvbnN0IGNhbGVuZGFyQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItY2FsZW5kYXJcIik7XG5cdFx0QXJyYXkuZnJvbShjYWxlbmRhckNvbnRhaW5lcikuZm9yRWFjaChjYWxlbmRhciA9PiB7XG5cdFx0XHRjYWxlbmRhci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5wcmV2ZW50Q2FsZW5kYXJDbG9zZSk7XG5cdFx0XHRjYWxlbmRhci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5wcmV2ZW50Q2FsZW5kYXJDbG9zZSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgaW5pdGlhbGl6YXRpb24gb2YgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgZGF0ZXBpY2tlciBpbnB1dCBhbmQgcmFuZ2UgaW5wdXQgZmllbGRzLlxuXHQgKi9cblx0cHJvdGVjdGVkIGFkZElucHV0TGlzdGVuZXJzKCkge1xuXHRcdGlmICghdGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3dzIGZvY3VzIHRyYW5zaXRpb24gZnJvbSB0aGUgZGF0ZXBpY2tlciBpbnB1dCBvciByYW5nZSBpbnB1dCBmaWVsZCB0b1xuXHRcdC8vIGZsYXRwaWNrciBjYWxlbmRhciB1c2luZyBhIGtleWJvYXJkLlxuXHRcdGNvbnN0IGFkZEZvY3VzQ2FsZW5kYXJMaXN0ZW5lciA9IChlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB7XG5cdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuXHRcdFx0XHRpZiAoZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLmZsYXRwaWNrckluc3RhbmNlLmlzT3Blbikge1xuXHRcdFx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5vcGVuKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgY2FsZW5kYXJDb250YWluZXIgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmNhbGVuZGFyQ29udGFpbmVyO1xuXHRcdFx0XHRcdGNvbnN0IGRheUVsZW1lbnQgPSBjYWxlbmRhckNvbnRhaW5lciAmJiBjYWxlbmRhckNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmZsYXRwaWNrci1kYXlbdGFiaW5kZXhdXCIpO1xuXG5cdFx0XHRcdFx0aWYgKGRheUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGRheUVsZW1lbnQuZm9jdXMoKTtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHVzZXIgbWFudWFsbHkgaW5wdXRzIGEgdmFsdWUgaW50byB0aGUgZGF0ZSBmaWVsZCBhbmQgcHJlc3NlcyBhcnJvdyBkb3duLFxuXHRcdFx0XHRcdFx0Ly8gZGF0ZXBpY2tlciBpbnB1dCBvbmNoYW5nZSB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIGZvY3VzIGlzIHJlbW92ZWQgZnJvbSBpdCBhbmRcblx0XHRcdFx0XHRcdC8vIGBmbGF0cGlja3JJbnN0YW5jZS5zZXREYXRlYCBhbmQgYGZsYXRwaWNrckluc3RhbmNlLmNoYW5nZU1vbnRoYCB3aWxsIGJlIGludm9rZWRcblx0XHRcdFx0XHRcdC8vIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBjaGFuZ2UgZm9jdXMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZGF5RWxlbWVudCAmJiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZUVsZW0pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVFbGVtLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0aWYgKHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dC5pbnB1dCkge1xuXHRcdFx0YWRkRm9jdXNDYWxlbmRhckxpc3RlbmVyKHRoaXMuaW5wdXQuaW5wdXQubmF0aXZlRWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucmFuZ2VJbnB1dCAmJiB0aGlzLnJhbmdlSW5wdXQuaW5wdXQpIHtcblx0XHRcdGFkZEZvY3VzQ2FsZW5kYXJMaXN0ZW5lcih0aGlzLnJhbmdlSW5wdXQuaW5wdXQubmF0aXZlRWxlbWVudCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgZmxhdHBpY2tyIGluc3RhbmNlIHdoaWxlIGtlZXBpbmcgdGhlIGRhdGUgdmFsdWVzIChvciB1cGRhdGluZyB0aGVtIGlmIG5ld0RhdGVzIGlzIHByb3ZpZGVkKVxuXHQgKlxuXHQgKiBVc2VkIHRvIHBpY2sgdXAgaW5wdXQgY2hhbmdlcyBvciBsb2NhbGUgY2hhbmdlcy5cblx0ICpcblx0ICogQHBhcmFtIG5ld0RhdGVzIEFuIG9wdGlvbmFsIFNpbXBsZUNoYW5nZSBvZiBkYXRlIHZhbHVlc1xuXHQgKi9cblx0cHJvdGVjdGVkIHJlc2V0RmxhdHBpY2tySW5zdGFuY2UobmV3RGF0ZXM/OiBTaW1wbGVDaGFuZ2UpIHtcblx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRsZXQgZGF0ZXMgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXM7XG5cdFx0XHRpZiAobmV3RGF0ZXMgJiYgdGhpcy5kaWREYXRlVmFsdWVDaGFuZ2UobmV3RGF0ZXMuY3VycmVudFZhbHVlLCBuZXdEYXRlcy5wcmV2aW91c1ZhbHVlKSkge1xuXHRcdFx0XHRkYXRlcyA9IG5ld0RhdGVzLmN1cnJlbnRWYWx1ZTtcblx0XHRcdH1cblx0XHRcdC8vIG9ubHkgcmVzZXQgdGhlIGZsYXRwaWNrciBpbnN0YW5jZSBvbiBJbnB1dCBjaGFuZ2VzXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlID0gZmxhdHBpY2tyKGAjJHt0aGlzLmlkfS1pbnB1dGAsIHRoaXMuZmxhdHBpY2tyT3B0aW9ucyk7XG5cdFx0XHR0aGlzLnNldERhdGVWYWx1ZXMoZGF0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYXJib24gdXNlcyBhIG51bWJlciBvZiBzcGVjaWZpYyBjbGFzc25hbWVzIGZvciBwYXJ0cyBvZiB0aGUgZmxhdHBpY2tyIC0gdGhpcyBpZGVtcG90ZW50IG1ldGhvZCBhcHBsaWVzIHRoZW0gaWYgbmVlZGVkLlxuXHQgKi9cblx0cHJvdGVjdGVkIHVwZGF0ZUNsYXNzTmFtZXMoKSB7XG5cdFx0aWYgKCF0aGlzLmVsZW1lbnRSZWYpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gZ2V0IGFsbCB0aGUgcG9zc2libGUgZmxhdHBpY2tycyBpbiB0aGUgZG9jdW1lbnQgLSB3ZSBuZWVkIHRvIGFkZCBjbGFzc2VzIHRvIChwb3RlbnRpYWxseSkgYWxsIG9mIHRoZW1cblx0XHRjb25zdCBjYWxlbmRhckNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuXHRcdGNvbnN0IG1vbnRoQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItbW9udGhcIik7XG5cdFx0Y29uc3Qgd2Vla2RheXNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci13ZWVrZGF5c1wiKTtcblx0XHRjb25zdCB3ZWVrZGF5Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3Itd2Vla2RheVwiKTtcblx0XHRjb25zdCBkYXlzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mbGF0cGlja3ItZGF5c1wiKTtcblx0XHRjb25zdCBkYXlDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsYXRwaWNrci1kYXlcIik7XG5cblx0XHQvLyBhZGQgY2xhc3NlcyB0byBsaXN0cyBvZiBlbGVtZW50c1xuXHRcdGNvbnN0IGFkZENsYXNzSWZOb3RFeGlzdHMgPSAoY2xhc3NuYW1lOiBzdHJpbmcsIGVsZW1lbnRMaXN0OiBOb2RlTGlzdE9mPEVsZW1lbnQ+KSA9PiB7XG5cdFx0XHRBcnJheS5mcm9tKGVsZW1lbnRMaXN0KS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRpZiAoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzbmFtZSkpIHtcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NuYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdC8vIGFkZCBjbGFzc2VzIChidXQgb25seSBpZiB0aGV5IGRvbid0IGV4aXN0LCBzbWFsbCBwZXJmIHdpbilcblx0XHRhZGRDbGFzc0lmTm90RXhpc3RzKFwiYngtLWRhdGUtcGlja2VyX19jYWxlbmRhclwiLCBjYWxlbmRhckNvbnRhaW5lcik7XG5cdFx0YWRkQ2xhc3NJZk5vdEV4aXN0cyhcImJ4LS1kYXRlLXBpY2tlcl9fbW9udGhcIiwgbW9udGhDb250YWluZXIpO1xuXHRcdGFkZENsYXNzSWZOb3RFeGlzdHMoXCJieC0tZGF0ZS1waWNrZXJfX3dlZWtkYXlzXCIsIHdlZWtkYXlzQ29udGFpbmVyKTtcblx0XHRhZGRDbGFzc0lmTm90RXhpc3RzKFwiYngtLWRhdGUtcGlja2VyX19kYXlzXCIsIGRheXNDb250YWluZXIpO1xuXG5cdFx0Ly8gYWRkIHdlZWtkYXkgY2xhc3NlcyBhbmQgZm9ybWF0IHRoZSB0ZXh0XG5cdFx0QXJyYXkuZnJvbSh3ZWVrZGF5Q29udGFpbmVyKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0ZWxlbWVudC5pbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYngtLWRhdGUtcGlja2VyX193ZWVrZGF5XCIpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gYWRkIGRheSBjbGFzc2VzIGFuZCBzcGVjaWFsIGNhc2UgdGhlIFwidG9kYXlcIiBlbGVtZW50IGJhc2VkIG9uIGB0aGlzLnZhbHVlYFxuXHRcdEFycmF5LmZyb20oZGF5Q29udGFpbmVyKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYngtLWRhdGUtcGlja2VyX19kYXlcIik7XG5cdFx0XHRpZiAoIXRoaXMudmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidG9kYXlcIikgJiYgdGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm5vLWJvcmRlclwiKTtcblx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0b2RheVwiKSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJuby1ib3JkZXJcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgdXBkYXRlQXR0cmlidXRlcygpIHtcblx0XHRjb25zdCBjYWxlbmRhckNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuXHRcdEFycmF5LmZyb20oY2FsZW5kYXJDb250YWluZXIpLmZvckVhY2goY2FsZW5kYXIgPT4ge1xuXHRcdFx0Y2FsZW5kYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInJlZ2lvblwiKTtcblx0XHRcdGNhbGVuZGFyLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5hcmlhTGFiZWwpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGdpdmVuIGRhdGUgdmFsdWUgYXJyYXkgdG8gYm90aCB0aGUgZmxhdHBpY2tyIGluc3RhbmNlIGFuZCB0aGUgYGlucHV0YChzKVxuXHQgKiBAcGFyYW0gZGF0ZXMgdGhlIGRhdGUgdmFsdWVzIHRvIGFwcGx5XG5cdCAqL1xuXHRwcm90ZWN0ZWQgc2V0RGF0ZVZhbHVlcyhkYXRlczogKERhdGUgfCBzdHJpbmcpW10pIHtcblx0XHRpZiAodGhpcy5pc0ZsYXRwaWNrckxvYWRlZCgpKSB7XG5cdFx0XHRjb25zdCBzaW5nbGVJbnB1dCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuaWR9LWlucHV0YCk7XG5cdFx0XHRjb25zdCByYW5nZUlucHV0ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGhpcy5pZH0tcmFuZ2VJbnB1dGApO1xuXG5cdFx0XHQvLyBgZmxhdHBpY2tySW5zdGFuY2Uuc2V0RGF0ZWAgcmVtb3ZlcyB0aGUgZm9jdXMgb24gdGhlIHNlbGVjdGVkIGRhdGUgZWxlbWVudCBhbmQgd2lsbFxuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBjaGFuZ2UgZm9jdXMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG9jdW1lbnQuIElmIGEgc2VsZWN0ZWQgZGF0ZSBpc1xuXHRcdFx0Ly8gZm9jdXNlZCBiZWZvcmUgYGZsYXRwaWNrckluc3RhbmNlLnNldERhdGVgIGlzIGludm9rZWQgdGhlbiBpdCBzaG91bGQgcmVtYWluIGZvY3VzZWQuXG5cdFx0XHRsZXQgc2hvdWxkUmVmb2N1c0RhdGVFbGVtZW50ID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVFbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHQvLyBzZXQgdGhlIGRhdGUgb24gdGhlIGluc3RhbmNlXG5cdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNldERhdGUoZGF0ZXMpO1xuXG5cdFx0XHRpZiAoc2hvdWxkUmVmb2N1c0RhdGVFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbS5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIHNldCBhIGRhdGUgdmFsdWUgb3IgYW4gZW1wdHkgc3RyaW5nLCBzbyB3ZSBzdGFydCB3aXRoIGFuIGVtcHR5IHN0cmluZ1xuXHRcdFx0bGV0IHNpbmdsZURhdGUgPSBcIlwiO1xuXHRcdFx0Ly8gaWYgZGF0ZSBpcyBhIHN0cmluZywgcGFyc2UgYW5kIGZvcm1hdFxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMF0gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0c2luZ2xlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UucGFyc2VEYXRlKHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdFx0c2luZ2xlRGF0ZSA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2UuZm9ybWF0RGF0ZShzaW5nbGVEYXRlLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0Ly8gaWYgZGF0ZSBpcyBub3QgYSBzdHJpbmcgd2UgY2FuIGFzc3VtZSBpdCdzIGEgRGF0ZSBhbmQgd2Ugc2hvdWxkIGZvcm1hdFxuXHRcdFx0fSBlbHNlIGlmICghIXRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0XHRzaW5nbGVEYXRlID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5mb3JtYXREYXRlKHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJhbmdlSW5wdXQpIHtcblx0XHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBzZXQgYSBkYXRlIHZhbHVlIG9yIGFuIGVtcHR5IHN0cmluZywgc28gd2Ugc3RhcnQgd2l0aCBhbiBlbXB0eSBzdHJpbmdcblx0XHRcdFx0bGV0IHJhbmdlRGF0ZSA9IFwiXCI7XG5cdFx0XHRcdC8vIGlmIGRhdGUgaXMgYSBzdHJpbmcsIHBhcnNlIGFuZCBmb3JtYXRcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyYW5nZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLnBhcnNlRGF0ZSh0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0udG9TdHJpbmcoKSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHRcdFx0XHRyYW5nZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmZvcm1hdERhdGUocmFuZ2VEYXRlLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHQvLyBpZiBkYXRlIGlzIG5vdCBhIHN0cmluZyB3ZSBjYW4gYXNzdW1lIGl0J3MgYSBEYXRlIGFuZCB3ZSBzaG91bGQgZm9ybWF0XG5cdFx0XHRcdH0gZWxzZSBpZiAoISF0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZXNbMV0pIHtcblx0XHRcdFx0XHRyYW5nZURhdGUgPSB0aGlzLmZsYXRwaWNrckluc3RhbmNlLmZvcm1hdERhdGUodGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzFdLCB0aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdC8vIGFwcGx5IHRoZSB2YWx1ZXNcblx0XHRcdFx0XHRyYW5nZUlucHV0LnZhbHVlID0gcmFuZ2VEYXRlO1xuXHRcdFx0XHRcdHNpbmdsZUlucHV0LnZhbHVlID0gc2luZ2xlRGF0ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIHByZXZlbnRDYWxlbmRhckNsb3NlID0gZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0cHJvdGVjdGVkIGRvU2VsZWN0KHNlbGVjdGVkVmFsdWU6IChEYXRlIHwgc3RyaW5nKVtdKSB7XG5cdFx0Ly8gSW4gcmFuZ2UgbW9kZSwgaWYgYSBkYXRlIGlzIHNlbGVjdGVkIGZyb20gdGhlIGZpcnN0IGNhbGVuZGFyIHRoYXQgaXMgZnJvbSB0aGUgcHJldmlvdXMgbW9udGgsXG5cdFx0Ly8gdGhlIG1vbnRoIHdpbGwgbm90IGJlIHVwZGF0ZWQgb24gdGhlIGNhbGVuZGFyIHVudGlsIHRoZSBjYWxlbmRhciBpcyByZS1vcGVuZWQuXG5cdFx0Ly8gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGUgY2FsZW5kYXIgaXMgdXBkYXRlZCB3aXRoIHRoZSBjb3JyZWN0IG1vbnRoLlxuXHRcdGlmICh0aGlzLnJhbmdlICYmIHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlc1swXSkge1xuXHRcdFx0Y29uc3QgY3VycmVudE1vbnRoID0gdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZWxlY3RlZERhdGVzWzBdLmdldE1vbnRoKCk7XG5cblx0XHRcdC8vIGBmbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aGAgcmVtb3ZlcyB0aGUgZm9jdXMgb24gdGhlIHNlbGVjdGVkIGRhdGUgZWxlbWVudCBhbmQgd2lsbFxuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBjaGFuZ2UgZm9jdXMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG9jdW1lbnQuIElmIGEgc2VsZWN0ZWQgZGF0ZSBpc1xuXHRcdFx0Ly8gZm9jdXNlZCBiZWZvcmUgYGZsYXRwaWNrckluc3RhbmNlLmNoYW5nZU1vbnRoYCBpcyBpbnZva2VkIHRoZW4gaXQgc2hvdWxkIHJlbWFpbiBmb2N1c2VkLlxuXHRcdFx0bGV0IHNob3VsZFJlZm9jdXNEYXRlRWxlbWVudCA9IHRoaXMuZmxhdHBpY2tySW5zdGFuY2Uuc2VsZWN0ZWREYXRlRWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdFx0dGhpcy5mbGF0cGlja3JJbnN0YW5jZS5jaGFuZ2VNb250aChjdXJyZW50TW9udGgsIGZhbHNlKTtcblxuXHRcdFx0aWYgKHNob3VsZFJlZm9jdXNEYXRlRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZsYXRwaWNrckluc3RhbmNlLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdH1cblx0XHR0aGlzLnZhbHVlQ2hhbmdlLmVtaXQoc2VsZWN0ZWRWYWx1ZSk7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2Uoc2VsZWN0ZWRWYWx1ZSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZGlkRGF0ZVZhbHVlQ2hhbmdlKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuXHRcdHJldHVybiBjdXJyZW50VmFsdWVbMF0gIT09IHByZXZpb3VzVmFsdWVbMF0gfHwgY3VycmVudFZhbHVlWzFdICE9PSBwcmV2aW91c1ZhbHVlWzFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1vcmUgYWR2YW5jZWQgY2hlY2tpbmcgb2YgdGhlIGxvYWRlZCBzdGF0ZSBvZiBmbGF0cGlja3Jcblx0ICovXG5cdHByb3RlY3RlZCBpc0ZsYXRwaWNrckxvYWRlZCgpIHtcblx0XHQvLyBjYXN0IHRoZSBpbnN0YW5jZSB0byBhIGJvb2xlYW4sIGFuZCBzb21lIG1ldGhvZCB0aGF0IGhhcyB0byBleGlzdCBmb3IgdGhlIGxpYnJhcnkgdG8gYmUgbG9hZGVkIGluIHRoaXMgY2FzZSBgc2V0RGF0ZWBcblx0XHRyZXR1cm4gISF0aGlzLmZsYXRwaWNrckluc3RhbmNlICYmICEhdGhpcy5mbGF0cGlja3JJbnN0YW5jZS5zZXREYXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJpZ2h0IGFycm93IEhUTUwgcGFzc2VkIHRvIGZsYXRwaWNrclxuXHQgKi9cblx0cHJvdGVjdGVkIHJpZ2h0QXJyb3dIVE1MKCkge1xuXHRcdHJldHVybiBgXG5cdFx0XHQ8c3ZnIHdpZHRoPVwiMTZweFwiIGhlaWdodD1cIjE2cHhcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG5cdFx0XHRcdDxwb2x5Z29uIHBvaW50cz1cIjExLDggNiwxMyA1LjMsMTIuMyA5LjYsOCA1LjMsMy43IDYsMyBcIi8+XG5cdFx0XHRcdDxyZWN0IHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHN0eWxlPVwiZmlsbDpub25lXCIgLz5cblx0XHRcdDwvc3ZnPmA7XG5cdH1cblxuXHQvKipcblx0ICogTGVmdCBhcnJvdyBIVE1MIHBhc3NlZCB0byBmbGF0cGlja3Jcblx0ICovXG5cdHByb3RlY3RlZCBsZWZ0QXJyb3dIVE1MKCkge1xuXHRcdHJldHVybiBgXG5cdFx0XHQ8c3ZnIHdpZHRoPVwiMTZweFwiIGhlaWdodD1cIjE2cHhcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG5cdFx0XHRcdDxwb2x5Z29uIHBvaW50cz1cIjUsOCAxMCwzIDEwLjcsMy43IDYuNCw4IDEwLjcsMTIuMyAxMCwxMyBcIi8+XG5cdFx0XHRcdDxyZWN0IHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHN0eWxlPVwiZmlsbDpub25lXCIgLz5cblx0XHRcdDwvc3ZnPmA7XG5cdH1cbn1cbiJdfQ==