/**
 *
 * carbon-angular v0.0.0 | overflow-menu.component.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, ContentChild, ElementRef, EventEmitter, Input, Output, TemplateRef, ViewEncapsulation } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
import { OverflowMenuDirective } from "./overflow-menu.directive";
/**
 * The OverFlow menu component encapsulates the OverFlowMenu directive, and the menu iconography into one convienent component
 *
 * [See demo](../../?path=/story/components-overflow-menu--basic)
 *
 * html:
 * ```
 * <ibm-overflow-menu>
 *	<ibm-overflow-menu-option>Option 1</ibm-overflow-menu-option>
 *	<ibm-overflow-menu-option>Option 2</ibm-overflow-menu-option>
 * </ibm-overflow-menu>
 * ```
 *
 * <example-url>../../iframe.html?id=components-overflow-menu--basic</example-url>
 */
export class OverflowMenu {
    constructor(elementRef, i18n) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
        this.flip = false;
        this.placement = "bottom";
        this.open = false;
        this.openChange = new EventEmitter();
        this.wrapperClass = "";
        /**
         * This appends additional classes to the overflow trigger/button.
         */
        this.triggerClass = "";
    }
    handleOpenChange(event) {
        this.open = event;
        this.openChange.emit(event);
    }
}
OverflowMenu.decorators = [
    { type: Component, args: [{
                selector: "ibm-overflow-menu",
                template: `
		<button
			[ibmOverflowMenu]="options"
			[ngClass]="{'bx--overflow-menu--open': open}"
			class="bx--overflow-menu {{triggerClass}}"
			[attr.aria-label]="buttonLabel"
			[flip]="flip"
			[isOpen]="open"
			(isOpenChange)="handleOpenChange($event)"
			[offset]="offset"
			[wrapperClass]="wrapperClass"
			aria-haspopup="true"
			class="bx--overflow-menu"
			type="button"
			[placement]="placement">
			<ng-template *ngIf="customTrigger; else defaultIcon" [ngTemplateOutlet]="customTrigger"></ng-template>
		</button>
		<ng-template #options>
			<ng-content></ng-content>
		</ng-template>
		<ng-template #defaultIcon>
			<svg ibmIcon="overflow-menu--vertical" size="16" class="bx--overflow-menu__icon"></svg>
		</ng-template>
	`,
                encapsulation: ViewEncapsulation.None,
                styles: [`
		.bx--overflow-menu--open {
			opacity: 1
		}

		/*
		Rotate the overflow menu container as well as the icon, since
		we calculate our menu position based on the container, not the icon.
		*/
		.bx--data-table-v2 .bx--overflow-menu {
			transform: rotate(90deg);
		}

		.bx--data-table-v2 .bx--overflow-menu__icon {
			transform: rotate(180deg);
		}
	`]
            }] }
];
/** @nocollapse */
OverflowMenu.ctorParameters = () => [
    { type: ElementRef },
    { type: I18n }
];
OverflowMenu.propDecorators = {
    buttonLabel: [{ type: Input }],
    flip: [{ type: Input }],
    placement: [{ type: Input }],
    open: [{ type: Input }],
    openChange: [{ type: Output }],
    customTrigger: [{ type: Input }],
    offset: [{ type: Input }],
    wrapperClass: [{ type: Input }],
    triggerClass: [{ type: Input }],
    overflowMenuDirective: [{ type: ContentChild, args: [OverflowMenuDirective, { static: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmZsb3ctbWVudS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2RpYWxvZy8iLCJzb3VyY2VzIjpbIm92ZXJmbG93LW1lbnUvb3ZlcmZsb3ctbWVudS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFdBQVcsRUFDWCxpQkFBaUIsRUFDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3RELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRWxFOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBOENILE1BQU0sT0FBTyxZQUFZO0lBOEJ4QixZQUFzQixVQUFzQixFQUFZLElBQVU7UUFBNUMsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUFZLFNBQUksR0FBSixJQUFJLENBQU07UUE3QnpELGdCQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO1FBRXJELFNBQUksR0FBRyxLQUFLLENBQUM7UUFFYixjQUFTLEdBQXFCLFFBQVEsQ0FBQztRQUV2QyxTQUFJLEdBQUcsS0FBSyxDQUFDO1FBRVosZUFBVSxHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7UUFXMUMsaUJBQVksR0FBRyxFQUFFLENBQUM7UUFFM0I7O1dBRUc7UUFDTSxpQkFBWSxHQUFHLEVBQUUsQ0FBQztJQUswQyxDQUFDO0lBRXRFLGdCQUFnQixDQUFDLEtBQWM7UUFDOUIsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0IsQ0FBQzs7O1lBaEZELFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBdUJUO2dCQWtCRCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTt5QkFqQjVCOzs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JSO2FBRUQ7Ozs7WUFyRUEsVUFBVTtZQU9GLElBQUk7OzswQkFnRVgsS0FBSzttQkFFTCxLQUFLO3dCQUVMLEtBQUs7bUJBRUwsS0FBSzt5QkFFTCxNQUFNOzRCQUlOLEtBQUs7cUJBS0wsS0FBSzsyQkFFTCxLQUFLOzJCQUtMLEtBQUs7b0NBR0wsWUFBWSxTQUFDLHFCQUFxQixFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0Q29udGVudENoaWxkLFxuXHRFbGVtZW50UmVmLFxuXHRFdmVudEVtaXR0ZXIsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdFRlbXBsYXRlUmVmLFxuXHRWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSTE4biB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IE92ZXJmbG93TWVudURpcmVjdGl2ZSB9IGZyb20gXCIuL292ZXJmbG93LW1lbnUuZGlyZWN0aXZlXCI7XG5cbi8qKlxuICogVGhlIE92ZXJGbG93IG1lbnUgY29tcG9uZW50IGVuY2Fwc3VsYXRlcyB0aGUgT3ZlckZsb3dNZW51IGRpcmVjdGl2ZSwgYW5kIHRoZSBtZW51IGljb25vZ3JhcGh5IGludG8gb25lIGNvbnZpZW5lbnQgY29tcG9uZW50XG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1vdmVyZmxvdy1tZW51LS1iYXNpYylcbiAqXG4gKiBodG1sOlxuICogYGBgXG4gKiA8aWJtLW92ZXJmbG93LW1lbnU+XG4gKlx0PGlibS1vdmVyZmxvdy1tZW51LW9wdGlvbj5PcHRpb24gMTwvaWJtLW92ZXJmbG93LW1lbnUtb3B0aW9uPlxuICpcdDxpYm0tb3ZlcmZsb3ctbWVudS1vcHRpb24+T3B0aW9uIDI8L2libS1vdmVyZmxvdy1tZW51LW9wdGlvbj5cbiAqIDwvaWJtLW92ZXJmbG93LW1lbnU+XG4gKiBgYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9Y29tcG9uZW50cy1vdmVyZmxvdy1tZW51LS1iYXNpYzwvZXhhbXBsZS11cmw+XG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tb3ZlcmZsb3ctbWVudVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxidXR0b25cblx0XHRcdFtpYm1PdmVyZmxvd01lbnVdPVwib3B0aW9uc1wiXG5cdFx0XHRbbmdDbGFzc109XCJ7J2J4LS1vdmVyZmxvdy1tZW51LS1vcGVuJzogb3Blbn1cIlxuXHRcdFx0Y2xhc3M9XCJieC0tb3ZlcmZsb3ctbWVudSB7e3RyaWdnZXJDbGFzc319XCJcblx0XHRcdFthdHRyLmFyaWEtbGFiZWxdPVwiYnV0dG9uTGFiZWxcIlxuXHRcdFx0W2ZsaXBdPVwiZmxpcFwiXG5cdFx0XHRbaXNPcGVuXT1cIm9wZW5cIlxuXHRcdFx0KGlzT3BlbkNoYW5nZSk9XCJoYW5kbGVPcGVuQ2hhbmdlKCRldmVudClcIlxuXHRcdFx0W29mZnNldF09XCJvZmZzZXRcIlxuXHRcdFx0W3dyYXBwZXJDbGFzc109XCJ3cmFwcGVyQ2xhc3NcIlxuXHRcdFx0YXJpYS1oYXNwb3B1cD1cInRydWVcIlxuXHRcdFx0Y2xhc3M9XCJieC0tb3ZlcmZsb3ctbWVudVwiXG5cdFx0XHR0eXBlPVwiYnV0dG9uXCJcblx0XHRcdFtwbGFjZW1lbnRdPVwicGxhY2VtZW50XCI+XG5cdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJjdXN0b21UcmlnZ2VyOyBlbHNlIGRlZmF1bHRJY29uXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY3VzdG9tVHJpZ2dlclwiPjwvbmctdGVtcGxhdGU+XG5cdFx0PC9idXR0b24+XG5cdFx0PG5nLXRlbXBsYXRlICNvcHRpb25zPlxuXHRcdFx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0PG5nLXRlbXBsYXRlICNkZWZhdWx0SWNvbj5cblx0XHRcdDxzdmcgaWJtSWNvbj1cIm92ZXJmbG93LW1lbnUtLXZlcnRpY2FsXCIgc2l6ZT1cIjE2XCIgY2xhc3M9XCJieC0tb3ZlcmZsb3ctbWVudV9faWNvblwiPjwvc3ZnPlxuXHRcdDwvbmctdGVtcGxhdGU+XG5cdGAsXG5cdHN0eWxlczogW2Bcblx0XHQuYngtLW92ZXJmbG93LW1lbnUtLW9wZW4ge1xuXHRcdFx0b3BhY2l0eTogMVxuXHRcdH1cblxuXHRcdC8qXG5cdFx0Um90YXRlIHRoZSBvdmVyZmxvdyBtZW51IGNvbnRhaW5lciBhcyB3ZWxsIGFzIHRoZSBpY29uLCBzaW5jZVxuXHRcdHdlIGNhbGN1bGF0ZSBvdXIgbWVudSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY29udGFpbmVyLCBub3QgdGhlIGljb24uXG5cdFx0Ki9cblx0XHQuYngtLWRhdGEtdGFibGUtdjIgLmJ4LS1vdmVyZmxvdy1tZW51IHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcblx0XHR9XG5cblx0XHQuYngtLWRhdGEtdGFibGUtdjIgLmJ4LS1vdmVyZmxvdy1tZW51X19pY29uIHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XG5cdFx0fVxuXHRgXSxcblx0ZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBPdmVyZmxvd01lbnUge1xuXHRASW5wdXQoKSBidXR0b25MYWJlbCA9IHRoaXMuaTE4bi5nZXQoKS5PVkVSRkxPV19NRU5VLk9WRVJGTE9XO1xuXG5cdEBJbnB1dCgpIGZsaXAgPSBmYWxzZTtcblxuXHRASW5wdXQoKSBwbGFjZW1lbnQ6IFwiYm90dG9tXCIgfCBcInRvcFwiID0gXCJib3R0b21cIjtcblxuXHRASW5wdXQoKSBvcGVuID0gZmFsc2U7XG5cblx0QE91dHB1dCgpIG9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjdXN0b20gb3ZlcmZsb3cgbWVudSB0cmlnZ2VyXG5cdCAqL1xuXHRASW5wdXQoKSBjdXN0b21UcmlnZ2VyOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cdC8qKlxuXHQgKiBUaGlzIHNwZWNpZmllcyBhbnkgdmVydGljYWwgYW5kIGhvcml6b250YWwgb2Zmc2V0IGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIGRpYWxvZ1xuXHQgKi9cblx0QElucHV0KCkgb2Zmc2V0OiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH07XG5cblx0QElucHV0KCkgd3JhcHBlckNsYXNzID0gXCJcIjtcblxuXHQvKipcblx0ICogVGhpcyBhcHBlbmRzIGFkZGl0aW9uYWwgY2xhc3NlcyB0byB0aGUgb3ZlcmZsb3cgdHJpZ2dlci9idXR0b24uXG5cdCAqL1xuXHRASW5wdXQoKSB0cmlnZ2VyQ2xhc3MgPSBcIlwiO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0QENvbnRlbnRDaGlsZChPdmVyZmxvd01lbnVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSBvdmVyZmxvd01lbnVEaXJlY3RpdmU6IE92ZXJmbG93TWVudURpcmVjdGl2ZTtcblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJvdGVjdGVkIGkxOG46IEkxOG4pIHt9XG5cblx0aGFuZGxlT3BlbkNoYW5nZShldmVudDogYm9vbGVhbikge1xuXHRcdHRoaXMub3BlbiA9IGV2ZW50O1xuXHRcdHRoaXMub3BlbkNoYW5nZS5lbWl0KGV2ZW50KTtcblx0fVxufVxuIl19