/**
 *
 * carbon-angular v0.0.0 | modal.component.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { ModalService } from "./modal.service";
import { Component, EventEmitter, HostListener, Input, Output, ElementRef, ViewChild } from "@angular/core";
import { cycleTabs, getFocusElementList } from "carbon-components-angular/common";
/**
 * Component to create modals for presenting content.
 *
 * [See demo](../../?path=/story/components-modal--basic)
 *
 * Using a modal in your application requires `ibm-placeholder` which would generally be
 * placed near the end of your app component template (app.component.ts or app.component.html) as:
 *
```html
<ibm-placeholder></ibm-placeholder>
```
 *
 * A more complete example for `Modal` is given as follows:
 *
 * Example modal definition:
 *
```typescript
@Component({
    selector: "app-sample-modal",
    template: `
                <ibm-modal size="xl" (overlaySelected)="closeModal()">
                    <ibm-modal-header (closeSelect)="closeModal()">Header text</ibm-modal-header>
                        <section class="modal-body">
                            <h1>Sample modal works.</h1>
                            <button class="btn--icon-link" nPopover="Hello there" title="Popover title" placement="right" appendInline="true">
                                <svg ibmIcon="info" size="sm"></svg>
                            </button>
                            {{modalText}}
                        </section>
                    <ibm-modal-footer><button ibmButton="primary" (click)="closeModal()">Close</button></ibm-modal-footer>
                </ibm-modal>`,
    styleUrls: ["./sample-modal.component.scss"]
})
export class SampleModal extends BaseModal {
    modalText: string;
    constructor(protected injector: Injector) {
        super();
        this.modalText = this.injector.get("modalText");
    }
}
```
 *
 * Example of opening the modal:
 *
```typescript
@Component({
    selector: "app-modal-demo",
    template: `
                <button ibmButton="primary" (click)="openModal('drill')">Drill-down modal</button>
                <ibm-placeholder></ibm-placeholder>`
})
export class ModalDemo {
    openModal() {
        this.modalService.create({component: SampleModal, inputs: {modalText: "Hello universe."}});
    }
}
```
 *
 * <example-url>../../iframe.html?id=components-modal--basic</example-url>
 */
export class Modal {
    /**
     * Creates an instance of `Modal`.
     */
    constructor(modalService) {
        this.modalService = modalService;
        /**
         * Classification of the modal.
         */
        this.theme = "default";
        this.ariaLabel = "default";
        /**
         * Controls the visibility of the modal when used directly in a template
         */
        this.open = false;
        /**
         * Specify whether the modal contains scrolling content. This property overrides the automatic
         * detection of the existence of scrolling content. Set this property to `true` to force
         * overflow indicator to show up or to `false` to force overflow indicator to disappear.
         * It is set to `null` by default which indicates not to override automatic detection.
         */
        this.hasScrollingContent = null;
        /**
         * Emits event when click occurs within `n-overlay` element. This is to track click events occurring outside bounds of the `Modal` object.
         */
        this.overlaySelected = new EventEmitter();
        /**
         * To emit the closing event of the modal window.
         */
        this.close = new EventEmitter();
        /**
         * An element should have 'modal-primary-focus' as an attribute to receive initial focus within the `Modal` component.
         */
        this.selectorPrimaryFocus = "[modal-primary-focus]";
    }
    /**
     * Label for the modal.
     *
     * @deprecated since v4
     */
    set modalLabel(value) {
        this.ariaLabel = value;
    }
    get modalLabel() {
        return this.ariaLabel;
    }
    ngOnChanges({ open }) {
        if (open) {
            if (open.currentValue) {
                // `100` is just enough time to allow the modal
                // to become visible, so that we can set focus
                setTimeout(() => this.focusInitialElement(), 100);
            }
            else if (this.trigger) {
                this.trigger.focus();
            }
        }
    }
    /**
     * Set document focus to be on the modal component after it is initialized.
     */
    ngAfterViewInit() {
        this.focusInitialElement();
    }
    /**
     * Handle keyboard events to close modal and tab through the content within the modal.
     */
    handleKeyboardEvent(event) {
        switch (event.key) {
            case "Escape": {
                event.stopImmediatePropagation(); // prevents events being fired for multiple modals if more than 2 open
                this.modalService.destroy(); // destroy top (latest) modal
                this.close.emit();
                break;
            }
            case "Tab": {
                cycleTabs(event, this.modal.nativeElement);
                break;
            }
        }
    }
    /**
     * This detects whether or not the modal contains scrolling content.
     *
     * To force trigger a detection (ie. on window resize), change or reset the value of the modal content.
     *
     * Use the `hasScrollingContent` input to manually override the overflow indicator.
     */
    get shouldShowScrollbar() {
        const modalContent = this.modal ? this.modal.nativeElement.querySelector(".bx--modal-content") : null;
        if (modalContent) {
            // get rounded value from height to match integer returned from scrollHeight
            const modalContentHeight = Math.ceil(modalContent.getBoundingClientRect().height);
            const modalContentScrollHeight = modalContent.scrollHeight;
            return modalContentScrollHeight > modalContentHeight;
        }
        else {
            return false;
        }
    }
    focusInitialElement() {
        const primaryFocusElement = this.modal.nativeElement.querySelector(this.selectorPrimaryFocus);
        if (primaryFocusElement && primaryFocusElement.focus) {
            setTimeout(() => primaryFocusElement.focus());
        }
        else if (getFocusElementList(this.modal.nativeElement).length > 0) {
            setTimeout(() => getFocusElementList(this.modal.nativeElement)[0].focus());
        }
        else {
            setTimeout(() => this.modal.nativeElement.focus());
        }
    }
}
Modal.decorators = [
    { type: Component, args: [{
                selector: "ibm-modal",
                template: `
		<ibm-overlay
			[theme]="theme"
			[open]="open"
			(overlaySelect)="overlaySelected.emit()">
			<div
				class="bx--modal-container"
				[ngClass]="{
					'bx--modal-container--xs': size === 'xs',
					'bx--modal-container--sm': size === 'sm',
					'bx--modal-container--lg': size === 'lg'
				}"
				role="dialog"
				aria-modal="true"
				style="z-index:1;"
				[attr.aria-label]="ariaLabel"
				#modal>
				<ng-content></ng-content>
				<div
					*ngIf="hasScrollingContent !== null ? hasScrollingContent : shouldShowScrollbar"
					class="bx--modal-content--overflow-indicator">
				</div>
			</div>
		</ibm-overlay>
	`
            }] }
];
/** @nocollapse */
Modal.ctorParameters = () => [
    { type: ModalService }
];
Modal.propDecorators = {
    size: [{ type: Input }],
    theme: [{ type: Input }],
    modalLabel: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    open: [{ type: Input }],
    trigger: [{ type: Input }],
    hasScrollingContent: [{ type: Input }],
    overlaySelected: [{ type: Output }],
    close: [{ type: Output }],
    modal: [{ type: ViewChild, args: ["modal", { static: true },] }],
    handleKeyboardEvent: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kYWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9tb2RhbC8iLCJzb3VyY2VzIjpbIm1vZGFsLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUVOLFNBQVMsRUFDVCxZQUFZLEVBQ1osWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBQ04sVUFBVSxFQUNWLFNBQVMsRUFHVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFFbEY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkRHO0FBNkJILE1BQU0sT0FBTyxLQUFLO0lBOERqQjs7T0FFRztJQUNILFlBQW1CLFlBQTBCO1FBQTFCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBNUQ3Qzs7V0FFRztRQUNNLFVBQUssR0FBeUIsU0FBUyxDQUFDO1FBZXhDLGNBQVMsR0FBRyxTQUFTLENBQUM7UUFFL0I7O1dBRUc7UUFDTSxTQUFJLEdBQUcsS0FBSyxDQUFDO1FBT3RCOzs7OztXQUtHO1FBQ00sd0JBQW1CLEdBQVksSUFBSSxDQUFDO1FBRTdDOztXQUVHO1FBQ08sb0JBQWUsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQy9DOztXQUVHO1FBQ08sVUFBSyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFPckM7O1dBRUc7UUFDSCx5QkFBb0IsR0FBRyx1QkFBdUIsQ0FBQztJQUtDLENBQUM7SUF2RGpEOzs7O09BSUc7SUFDSCxJQUFhLFVBQVUsQ0FBQyxLQUFhO1FBQ3BDLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDYixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDdkIsQ0FBQztJQThDRCxXQUFXLENBQUMsRUFBRSxJQUFJLEVBQWlCO1FBQ2xDLElBQUksSUFBSSxFQUFFO1lBQ1QsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUN0QiwrQ0FBK0M7Z0JBQy9DLDhDQUE4QztnQkFDOUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQ2xEO2lCQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDeEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNyQjtTQUNEO0lBQ0YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZUFBZTtRQUNkLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRDs7T0FFRztJQUVILG1CQUFtQixDQUFDLEtBQW9CO1FBQ3ZDLFFBQVEsS0FBSyxDQUFDLEdBQUcsRUFBRTtZQUNsQixLQUFLLFFBQVEsQ0FBQyxDQUFDO2dCQUNkLEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLENBQUUsc0VBQXNFO2dCQUN6RyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUUsNkJBQTZCO2dCQUMzRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNsQixNQUFNO2FBQ047WUFFRCxLQUFLLEtBQUssQ0FBQyxDQUFDO2dCQUNYLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDM0MsTUFBTTthQUNOO1NBQ0Q7SUFDRixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsSUFBSSxtQkFBbUI7UUFDdEIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUN0RyxJQUFJLFlBQVksRUFBRTtZQUNqQiw0RUFBNEU7WUFDNUUsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xGLE1BQU0sd0JBQXdCLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQztZQUMzRCxPQUFPLHdCQUF3QixHQUFHLGtCQUFrQixDQUFDO1NBQ3JEO2FBQU07WUFDTixPQUFPLEtBQUssQ0FBQztTQUNiO0lBQ0YsQ0FBQztJQUVTLG1CQUFtQjtRQUM1QixNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUM5RixJQUFJLG1CQUFtQixJQUFJLG1CQUFtQixDQUFDLEtBQUssRUFBRTtZQUNyRCxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUM5QzthQUFNLElBQUksbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3BFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDM0U7YUFBTTtZQUNOLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ25EO0lBQ0YsQ0FBQzs7O1lBbEtELFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsV0FBVztnQkFDckIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF3QlQ7YUFDRDs7OztZQXRHUSxZQUFZOzs7bUJBMkduQixLQUFLO29CQUlMLEtBQUs7eUJBT0wsS0FBSzt3QkFRTCxLQUFLO21CQUtMLEtBQUs7c0JBS0wsS0FBSztrQ0FRTCxLQUFLOzhCQUtMLE1BQU07b0JBSU4sTUFBTTtvQkFLTixTQUFTLFNBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtrQ0FrQ25DLFlBQVksU0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb2RhbFNlcnZpY2UgfSBmcm9tIFwiLi9tb2RhbC5zZXJ2aWNlXCI7XG5pbXBvcnQge1xuXHRBZnRlclZpZXdJbml0LFxuXHRDb21wb25lbnQsXG5cdEV2ZW50RW1pdHRlcixcblx0SG9zdExpc3RlbmVyLFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRFbGVtZW50UmVmLFxuXHRWaWV3Q2hpbGQsXG5cdFNpbXBsZUNoYW5nZXMsXG5cdE9uQ2hhbmdlc1xufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgY3ljbGVUYWJzLCBnZXRGb2N1c0VsZW1lbnRMaXN0IH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvY29tbW9uXCI7XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIGNyZWF0ZSBtb2RhbHMgZm9yIHByZXNlbnRpbmcgY29udGVudC5cbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLW1vZGFsLS1iYXNpYylcbiAqXG4gKiBVc2luZyBhIG1vZGFsIGluIHlvdXIgYXBwbGljYXRpb24gcmVxdWlyZXMgYGlibS1wbGFjZWhvbGRlcmAgd2hpY2ggd291bGQgZ2VuZXJhbGx5IGJlXG4gKiBwbGFjZWQgbmVhciB0aGUgZW5kIG9mIHlvdXIgYXBwIGNvbXBvbmVudCB0ZW1wbGF0ZSAoYXBwLmNvbXBvbmVudC50cyBvciBhcHAuY29tcG9uZW50Lmh0bWwpIGFzOlxuICpcbmBgYGh0bWxcbjxpYm0tcGxhY2Vob2xkZXI+PC9pYm0tcGxhY2Vob2xkZXI+XG5gYGBcbiAqXG4gKiBBIG1vcmUgY29tcGxldGUgZXhhbXBsZSBmb3IgYE1vZGFsYCBpcyBnaXZlbiBhcyBmb2xsb3dzOlxuICpcbiAqIEV4YW1wbGUgbW9kYWwgZGVmaW5pdGlvbjpcbiAqXG5gYGB0eXBlc2NyaXB0XG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiYXBwLXNhbXBsZS1tb2RhbFwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdFx0XHQ8aWJtLW1vZGFsIHNpemU9XCJ4bFwiIChvdmVybGF5U2VsZWN0ZWQpPVwiY2xvc2VNb2RhbCgpXCI+XG5cdFx0XHRcdFx0PGlibS1tb2RhbC1oZWFkZXIgKGNsb3NlU2VsZWN0KT1cImNsb3NlTW9kYWwoKVwiPkhlYWRlciB0ZXh0PC9pYm0tbW9kYWwtaGVhZGVyPlxuXHRcdFx0XHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG5cdFx0XHRcdFx0XHRcdDxoMT5TYW1wbGUgbW9kYWwgd29ya3MuPC9oMT5cblx0XHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cImJ0bi0taWNvbi1saW5rXCIgblBvcG92ZXI9XCJIZWxsbyB0aGVyZVwiIHRpdGxlPVwiUG9wb3ZlciB0aXRsZVwiIHBsYWNlbWVudD1cInJpZ2h0XCIgYXBwZW5kSW5saW5lPVwidHJ1ZVwiPlxuXHRcdFx0XHRcdFx0XHRcdDxzdmcgaWJtSWNvbj1cImluZm9cIiBzaXplPVwic21cIj48L3N2Zz5cblx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdHt7bW9kYWxUZXh0fX1cblx0XHRcdFx0XHRcdDwvc2VjdGlvbj5cblx0XHRcdFx0XHQ8aWJtLW1vZGFsLWZvb3Rlcj48YnV0dG9uIGlibUJ1dHRvbj1cInByaW1hcnlcIiAoY2xpY2spPVwiY2xvc2VNb2RhbCgpXCI+Q2xvc2U8L2J1dHRvbj48L2libS1tb2RhbC1mb290ZXI+XG5cdFx0XHRcdDwvaWJtLW1vZGFsPmAsXG5cdHN0eWxlVXJsczogW1wiLi9zYW1wbGUtbW9kYWwuY29tcG9uZW50LnNjc3NcIl1cbn0pXG5leHBvcnQgY2xhc3MgU2FtcGxlTW9kYWwgZXh0ZW5kcyBCYXNlTW9kYWwge1xuXHRtb2RhbFRleHQ6IHN0cmluZztcblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGluamVjdG9yOiBJbmplY3Rvcikge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5tb2RhbFRleHQgPSB0aGlzLmluamVjdG9yLmdldChcIm1vZGFsVGV4dFwiKTtcblx0fVxufVxuYGBgXG4gKlxuICogRXhhbXBsZSBvZiBvcGVuaW5nIHRoZSBtb2RhbDpcbiAqXG5gYGB0eXBlc2NyaXB0XG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiYXBwLW1vZGFsLWRlbW9cIixcblx0dGVtcGxhdGU6IGBcblx0XHRcdFx0PGJ1dHRvbiBpYm1CdXR0b249XCJwcmltYXJ5XCIgKGNsaWNrKT1cIm9wZW5Nb2RhbCgnZHJpbGwnKVwiPkRyaWxsLWRvd24gbW9kYWw8L2J1dHRvbj5cblx0XHRcdFx0PGlibS1wbGFjZWhvbGRlcj48L2libS1wbGFjZWhvbGRlcj5gXG59KVxuZXhwb3J0IGNsYXNzIE1vZGFsRGVtbyB7XG5cdG9wZW5Nb2RhbCgpIHtcblx0XHR0aGlzLm1vZGFsU2VydmljZS5jcmVhdGUoe2NvbXBvbmVudDogU2FtcGxlTW9kYWwsIGlucHV0czoge21vZGFsVGV4dDogXCJIZWxsbyB1bml2ZXJzZS5cIn19KTtcblx0fVxufVxuYGBgXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNvbXBvbmVudHMtbW9kYWwtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1tb2RhbFwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxpYm0tb3ZlcmxheVxuXHRcdFx0W3RoZW1lXT1cInRoZW1lXCJcblx0XHRcdFtvcGVuXT1cIm9wZW5cIlxuXHRcdFx0KG92ZXJsYXlTZWxlY3QpPVwib3ZlcmxheVNlbGVjdGVkLmVtaXQoKVwiPlxuXHRcdFx0PGRpdlxuXHRcdFx0XHRjbGFzcz1cImJ4LS1tb2RhbC1jb250YWluZXJcIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0J2J4LS1tb2RhbC1jb250YWluZXItLXhzJzogc2l6ZSA9PT0gJ3hzJyxcblx0XHRcdFx0XHQnYngtLW1vZGFsLWNvbnRhaW5lci0tc20nOiBzaXplID09PSAnc20nLFxuXHRcdFx0XHRcdCdieC0tbW9kYWwtY29udGFpbmVyLS1sZyc6IHNpemUgPT09ICdsZydcblx0XHRcdFx0fVwiXG5cdFx0XHRcdHJvbGU9XCJkaWFsb2dcIlxuXHRcdFx0XHRhcmlhLW1vZGFsPVwidHJ1ZVwiXG5cdFx0XHRcdHN0eWxlPVwiei1pbmRleDoxO1wiXG5cdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcblx0XHRcdFx0I21vZGFsPlxuXHRcdFx0XHQ8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHQqbmdJZj1cImhhc1Njcm9sbGluZ0NvbnRlbnQgIT09IG51bGwgPyBoYXNTY3JvbGxpbmdDb250ZW50IDogc2hvdWxkU2hvd1Njcm9sbGJhclwiXG5cdFx0XHRcdFx0Y2xhc3M9XCJieC0tbW9kYWwtY29udGVudC0tb3ZlcmZsb3ctaW5kaWNhdG9yXCI+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9pYm0tb3ZlcmxheT5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBNb2RhbCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcyB7XG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSBtb2RhbCB0byBkaXNwbGF5LlxuXHQgKi9cblx0QElucHV0KCkgc2l6ZTogXCJ4c1wiIHwgXCJzbVwiIHwgXCJsZ1wiO1xuXHQvKipcblx0ICogQ2xhc3NpZmljYXRpb24gb2YgdGhlIG1vZGFsLlxuXHQgKi9cblx0QElucHV0KCkgdGhlbWU6IFwiZGVmYXVsdFwiIHwgXCJkYW5nZXJcIiA9IFwiZGVmYXVsdFwiO1xuXG5cdC8qKlxuXHQgKiBMYWJlbCBmb3IgdGhlIG1vZGFsLlxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NFxuXHQgKi9cblx0QElucHV0KCkgc2V0IG1vZGFsTGFiZWwodmFsdWU6IHN0cmluZykge1xuXHRcdHRoaXMuYXJpYUxhYmVsID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgbW9kYWxMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcmlhTGFiZWw7XG5cdH1cblxuXHRASW5wdXQoKSBhcmlhTGFiZWwgPSBcImRlZmF1bHRcIjtcblxuXHQvKipcblx0ICogQ29udHJvbHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIG1vZGFsIHdoZW4gdXNlZCBkaXJlY3RseSBpbiBhIHRlbXBsYXRlXG5cdCAqL1xuXHRASW5wdXQoKSBvcGVuID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSBlbGVtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIG1vZGFsLCB3aGljaCBzaG91bGQgcmVjZWl2ZSBmb2N1cyB3aGVuIHRoZSBtb2RhbCBjbG9zZXNcblx0ICovXG5cdEBJbnB1dCgpIHRyaWdnZXI6IEhUTUxFbGVtZW50O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZ5IHdoZXRoZXIgdGhlIG1vZGFsIGNvbnRhaW5zIHNjcm9sbGluZyBjb250ZW50LiBUaGlzIHByb3BlcnR5IG92ZXJyaWRlcyB0aGUgYXV0b21hdGljXG5cdCAqIGRldGVjdGlvbiBvZiB0aGUgZXhpc3RlbmNlIG9mIHNjcm9sbGluZyBjb250ZW50LiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgdHJ1ZWAgdG8gZm9yY2Vcblx0ICogb3ZlcmZsb3cgaW5kaWNhdG9yIHRvIHNob3cgdXAgb3IgdG8gYGZhbHNlYCB0byBmb3JjZSBvdmVyZmxvdyBpbmRpY2F0b3IgdG8gZGlzYXBwZWFyLlxuXHQgKiBJdCBpcyBzZXQgdG8gYG51bGxgIGJ5IGRlZmF1bHQgd2hpY2ggaW5kaWNhdGVzIG5vdCB0byBvdmVycmlkZSBhdXRvbWF0aWMgZGV0ZWN0aW9uLlxuXHQgKi9cblx0QElucHV0KCkgaGFzU2Nyb2xsaW5nQ29udGVudDogYm9vbGVhbiA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IHdoZW4gY2xpY2sgb2NjdXJzIHdpdGhpbiBgbi1vdmVybGF5YCBlbGVtZW50LiBUaGlzIGlzIHRvIHRyYWNrIGNsaWNrIGV2ZW50cyBvY2N1cnJpbmcgb3V0c2lkZSBib3VuZHMgb2YgdGhlIGBNb2RhbGAgb2JqZWN0LlxuXHQgKi9cblx0QE91dHB1dCgpIG92ZXJsYXlTZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0LyoqXG5cdCAqIFRvIGVtaXQgdGhlIGNsb3NpbmcgZXZlbnQgb2YgdGhlIG1vZGFsIHdpbmRvdy5cblx0ICovXG5cdEBPdXRwdXQoKSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0LyoqXG5cdCAqIE1haW50YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgdmlldyBET00gZWxlbWVudCBvZiB0aGUgYE1vZGFsYC5cblx0ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0QFZpZXdDaGlsZChcIm1vZGFsXCIsIHsgc3RhdGljOiB0cnVlIH0pIG1vZGFsOiBFbGVtZW50UmVmO1xuXG5cdC8qKlxuXHQgKiBBbiBlbGVtZW50IHNob3VsZCBoYXZlICdtb2RhbC1wcmltYXJ5LWZvY3VzJyBhcyBhbiBhdHRyaWJ1dGUgdG8gcmVjZWl2ZSBpbml0aWFsIGZvY3VzIHdpdGhpbiB0aGUgYE1vZGFsYCBjb21wb25lbnQuXG5cdCAqL1xuXHRzZWxlY3RvclByaW1hcnlGb2N1cyA9IFwiW21vZGFsLXByaW1hcnktZm9jdXNdXCI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1vZGFsYC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge31cblxuXHRuZ09uQ2hhbmdlcyh7IG9wZW4gfTogU2ltcGxlQ2hhbmdlcykge1xuXHRcdGlmIChvcGVuKSB7XG5cdFx0XHRpZiAob3Blbi5jdXJyZW50VmFsdWUpIHtcblx0XHRcdFx0Ly8gYDEwMGAgaXMganVzdCBlbm91Z2ggdGltZSB0byBhbGxvdyB0aGUgbW9kYWxcblx0XHRcdFx0Ly8gdG8gYmVjb21lIHZpc2libGUsIHNvIHRoYXQgd2UgY2FuIHNldCBmb2N1c1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHRoaXMuZm9jdXNJbml0aWFsRWxlbWVudCgpLCAxMDApO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnRyaWdnZXIpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBkb2N1bWVudCBmb2N1cyB0byBiZSBvbiB0aGUgbW9kYWwgY29tcG9uZW50IGFmdGVyIGl0IGlzIGluaXRpYWxpemVkLlxuXHQgKi9cblx0bmdBZnRlclZpZXdJbml0KCkge1xuXHRcdHRoaXMuZm9jdXNJbml0aWFsRWxlbWVudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBrZXlib2FyZCBldmVudHMgdG8gY2xvc2UgbW9kYWwgYW5kIHRhYiB0aHJvdWdoIHRoZSBjb250ZW50IHdpdGhpbiB0aGUgbW9kYWwuXG5cdCAqL1xuXHRASG9zdExpc3RlbmVyKFwia2V5ZG93blwiLCBbXCIkZXZlbnRcIl0pXG5cdGhhbmRsZUtleWJvYXJkRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LmtleSkge1xuXHRcdFx0Y2FzZSBcIkVzY2FwZVwiOiB7XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAgLy8gcHJldmVudHMgZXZlbnRzIGJlaW5nIGZpcmVkIGZvciBtdWx0aXBsZSBtb2RhbHMgaWYgbW9yZSB0aGFuIDIgb3BlblxuXHRcdFx0XHR0aGlzLm1vZGFsU2VydmljZS5kZXN0cm95KCk7ICAvLyBkZXN0cm95IHRvcCAobGF0ZXN0KSBtb2RhbFxuXHRcdFx0XHR0aGlzLmNsb3NlLmVtaXQoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNhc2UgXCJUYWJcIjoge1xuXHRcdFx0XHRjeWNsZVRhYnMoZXZlbnQsIHRoaXMubW9kYWwubmF0aXZlRWxlbWVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGRldGVjdHMgd2hldGhlciBvciBub3QgdGhlIG1vZGFsIGNvbnRhaW5zIHNjcm9sbGluZyBjb250ZW50LlxuXHQgKlxuXHQgKiBUbyBmb3JjZSB0cmlnZ2VyIGEgZGV0ZWN0aW9uIChpZS4gb24gd2luZG93IHJlc2l6ZSksIGNoYW5nZSBvciByZXNldCB0aGUgdmFsdWUgb2YgdGhlIG1vZGFsIGNvbnRlbnQuXG5cdCAqXG5cdCAqIFVzZSB0aGUgYGhhc1Njcm9sbGluZ0NvbnRlbnRgIGlucHV0IHRvIG1hbnVhbGx5IG92ZXJyaWRlIHRoZSBvdmVyZmxvdyBpbmRpY2F0b3IuXG5cdCAqL1xuXHRnZXQgc2hvdWxkU2hvd1Njcm9sbGJhcigpIHtcblx0XHRjb25zdCBtb2RhbENvbnRlbnQgPSB0aGlzLm1vZGFsID8gdGhpcy5tb2RhbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYngtLW1vZGFsLWNvbnRlbnRcIikgOiBudWxsO1xuXHRcdGlmIChtb2RhbENvbnRlbnQpIHtcblx0XHRcdC8vIGdldCByb3VuZGVkIHZhbHVlIGZyb20gaGVpZ2h0IHRvIG1hdGNoIGludGVnZXIgcmV0dXJuZWQgZnJvbSBzY3JvbGxIZWlnaHRcblx0XHRcdGNvbnN0IG1vZGFsQ29udGVudEhlaWdodCA9IE1hdGguY2VpbChtb2RhbENvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcblx0XHRcdGNvbnN0IG1vZGFsQ29udGVudFNjcm9sbEhlaWdodCA9IG1vZGFsQ29udGVudC5zY3JvbGxIZWlnaHQ7XG5cdFx0XHRyZXR1cm4gbW9kYWxDb250ZW50U2Nyb2xsSGVpZ2h0ID4gbW9kYWxDb250ZW50SGVpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIGZvY3VzSW5pdGlhbEVsZW1lbnQoKSB7XG5cdFx0Y29uc3QgcHJpbWFyeUZvY3VzRWxlbWVudCA9IHRoaXMubW9kYWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3JQcmltYXJ5Rm9jdXMpO1xuXHRcdGlmIChwcmltYXJ5Rm9jdXNFbGVtZW50ICYmIHByaW1hcnlGb2N1c0VsZW1lbnQuZm9jdXMpIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4gcHJpbWFyeUZvY3VzRWxlbWVudC5mb2N1cygpKTtcblx0XHR9IGVsc2UgaWYgKGdldEZvY3VzRWxlbWVudExpc3QodGhpcy5tb2RhbC5uYXRpdmVFbGVtZW50KS5sZW5ndGggPiAwKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IGdldEZvY3VzRWxlbWVudExpc3QodGhpcy5tb2RhbC5uYXRpdmVFbGVtZW50KVswXS5mb2N1cygpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLm1vZGFsLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKSk7XG5cdFx0fVxuXHR9XG59XG4iXX0=