/**
 *
 * carbon-angular v0.0.0 | pagination-nav.component.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { PaginationModel } from "../pagination-model.class";
import { Component, Input, Output, EventEmitter } from "@angular/core";
import { I18n } from "carbon-components-angular/i18n";
import { ExperimentalService } from "carbon-components-angular/experimental";
import { merge } from "carbon-components-angular/utils";
import { range } from "carbon-components-angular/common";
/**
 * Use pagination when you have multiple pages of data to handle.
 *
 * [See demo](../../?path=/story/components-pagination-nav--basic)
 *
 * ```html
 * <ibm-pagination-nav [model]="model" (selectPage)="selectPage($event)"></ibm-pagination-nav>
 * ```
 *
 * In your `selectPage()` method set the `model.currentPage` to selected page, _after_
 * you load the page.
 *
 * ```typescript
 * selectPage(page) {
 * 	// ... your code to load the page goes here
 *
 * 	this.model.currentPage = page;
 *
 * 	// ... anything you want to do after page selection changes goes here
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=components-pagination-nav--basic</example-url>
 */
export class PaginationNav {
    constructor(i18n, experimental) {
        this.i18n = i18n;
        this.experimental = experimental;
        /**
         * Set to `true` to disable the backward/forward buttons.
         */
        this.disabled = false;
        /**
         * Number of items to show in pagination. Minimum is 4.
         */
        this.numOfItemsToShow = 4;
        /**
         * Emits the new page number.
         *
         * You should tie into this and update `model.currentPage` once the fresh
         * data is finally loaded.
         */
        this.selectPage = new EventEmitter();
        this.nextItemText = this.i18n.getOverridable("PAGINATION.NEXT");
        this.previousItemText = this.i18n.getOverridable("PAGINATION.PREVIOUS");
        PaginationNav.paginationCounter++;
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"NEXT": "Next",
     *		"PREVIOUS": "Previous",
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("PAGINATION"), value);
        this.nextItemText.override(valueWithDefaults.NEXT);
        this.previousItemText.override(valueWithDefaults.PREVIOUS);
    }
    get totalNumbersArray() {
        return range(this.totalDataLength + 1, 1);
    }
    get currentPage() {
        return this.model.currentPage;
    }
    set currentPage(value) {
        value = Number(value);
        // emits the value to allow the user to update current page
        // in the model once the page is loaded
        this.selectPage.emit(value);
    }
    get totalDataLength() {
        return this.model.totalDataLength;
    }
    get startOffset() {
        return this.numOfItemsToShow <= 4 && this.currentPage > 1 ? 0 : 1;
    }
    get frontCuts() {
        const cuts = this.getCuts();
        return cuts.front;
    }
    get backCuts() {
        const cuts = this.getCuts();
        return cuts.back;
    }
    get leftArrowDisabled() {
        return this.disabled || this.currentPage === 1;
    }
    get rightArrowDisabled() {
        return this.disabled || this.currentPage === this.totalDataLength;
    }
    handleOverflowSelection(page) {
        if (typeof page === "number") {
            this.currentPage = page;
        }
    }
    jumpToNext() {
        this.currentPage = this.currentPage < this.totalDataLength ? this.currentPage + 1 : this.totalDataLength;
    }
    jumpToPrevious() {
        this.currentPage = this.currentPage > 1 ? this.currentPage - 1 : 1;
    }
    getPages() {
        if (this.totalDataLength <= 1) {
            return null;
        }
        const cuts = this.getCuts();
        return this.totalNumbersArray.slice(this.startOffset + cuts.front, (1 + cuts.back) * -1);
    }
    getCuts(splitPoint = null) {
        const page = this.currentPage - 1;
        const totalItems = this.totalDataLength;
        const itemsThatFit = this.numOfItemsToShow;
        if (itemsThatFit >= totalItems) {
            return {
                front: 0,
                back: 0
            };
        }
        const split = splitPoint || Math.ceil(itemsThatFit / 2) - 1;
        let frontHidden = page + 1 - split;
        let backHidden = totalItems - page - (itemsThatFit - split) + 1;
        if (frontHidden <= 1) {
            backHidden -= frontHidden <= 0 ? Math.abs(frontHidden) + 1 : 0;
            frontHidden = 0;
        }
        if (backHidden <= 1) {
            frontHidden -= backHidden <= 0 ? Math.abs(backHidden) + 1 : 0;
            backHidden = 0;
        }
        return {
            front: frontHidden,
            back: backHidden
        };
    }
}
PaginationNav.paginationCounter = 0;
PaginationNav.decorators = [
    { type: Component, args: [{
                selector: "ibm-pagination-nav",
                template: `
	<div>
		<div class="bx--pagination-nav">
			<ul class="bx--pagination-nav__list">
				<li class="bx--pagination-nav__list-item">
					<button
						class="bx--btn bx--btn--ghost bx--pagination-nav-previous
						bx--btn--icon-only bx--tooltip__trigger bx--tooltip--a11y bx--tooltip--bottom bx--tooltip--align-center"
						[disabled]="leftArrowDisabled"
						(click)="jumpToPrevious()">
						<span class="bx--assistive-text">{{previousItemText.subject | async}}</span>
						<svg
							ibmIcon="caret--left"
							size="16"
							style="display: inherit"
							class="bx--btn__icon">
						</svg>
					</button>
				</li>
				<ibm-pagination-nav-item
					*ngIf="this.numOfItemsToShow >= 5 || (this.numOfItemsToShow <= 4 && currentPage <= 1)"
					page="1"
					(click)="currentPage = 1"
					[isActive]="currentPage == 1">
				</ibm-pagination-nav-item>
				<ibm-pagination-overflow
					*ngIf="frontCuts"
					[count]="frontCuts"
					[fromIndex]="startOffset"
					(change)="handleOverflowSelection($event)">
				</ibm-pagination-overflow>
				<ibm-pagination-nav-item
					*ngFor="let page of getPages();"
					[page]="page"
					(click)="currentPage = page"
					[isActive]="currentPage == page">
				</ibm-pagination-nav-item>
				<ibm-pagination-overflow
					*ngIf="backCuts"
					[count]="backCuts"
					[fromIndex]="totalNumbersArray.length - backCuts - 1"
					(change)="handleOverflowSelection($event)">
				</ibm-pagination-overflow>
				<ibm-pagination-nav-item
					*ngIf="totalDataLength > 1"
					[page]="totalNumbersArray.length"
					(click)="currentPage = totalNumbersArray.length"
					[isActive]="currentPage == totalNumbersArray.length">
				</ibm-pagination-nav-item>
				<li class="bx--pagination-nav__list-item">
					<button
						class="bx--btn bx--btn--ghost bx--pagination-nav-next
						bx--btn--icon-only bx--tooltip__trigger bx--tooltip--a11y bx--tooltip--bottom bx--tooltip--align-center"
						[disabled]="rightArrowDisabled"
						(click)="jumpToNext()">
						<span class="bx--assistive-text">{{nextItemText.subject | async}}</span>
						<svg
							ibmIcon="caret--right"
							size="16"
							style="display: inherit"
							class="bx--btn__icon">
						</svg>
					</button>
				</li>
			</ul>
		</div>
	</div>
	`
            }] }
];
/** @nocollapse */
PaginationNav.ctorParameters = () => [
    { type: I18n },
    { type: ExperimentalService }
];
PaginationNav.propDecorators = {
    model: [{ type: Input }],
    disabled: [{ type: Input }],
    numOfItemsToShow: [{ type: Input }],
    translations: [{ type: Input }],
    selectPage: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi1uYXYuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9wYWdpbmF0aW9uLyIsInNvdXJjZXMiOlsicGFnaW5hdGlvbi1uYXYvcGFnaW5hdGlvbi1uYXYuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxJQUFJLEVBQWUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNuRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUM3RSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDeEQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBT3pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVCRztBQXdFSCxNQUFNLE9BQU8sYUFBYTtJQW1GekIsWUFBc0IsSUFBVSxFQUFZLFlBQWlDO1FBQXZELFNBQUksR0FBSixJQUFJLENBQU07UUFBWSxpQkFBWSxHQUFaLFlBQVksQ0FBcUI7UUE3RTdFOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQUMxQjs7V0FFRztRQUNNLHFCQUFnQixHQUFHLENBQUMsQ0FBQztRQWtCOUI7Ozs7O1dBS0c7UUFDTyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQTJDbEQsaUJBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzNELHFCQUFnQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFHbEUsYUFBYSxDQUFDLGlCQUFpQixFQUFFLENB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QztTQUNmO1FBQ0QsT0FBTztZQUNOLEtBQUssRUFBRSxXQUFXO1lBQ2xCLElBQUksRUFBRSxVQUFVO1NBQ2hCLENBQUM7SUFDSCxDQUFDOztBQXZJTSwrQkFBaUIsR0FBRyxDQUFDLENBQUM7O1lBeEU3QixTQUFTLFNBQUM7Z0JBQ1YsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBbUVUO2FBQ0Q7Ozs7WUF4R1EsSUFBSTtZQUNKLG1CQUFtQjs7O29CQTZHMUIsS0FBSzt1QkFJTCxLQUFLOytCQUlMLEtBQUs7MkJBV0wsS0FBSzt5QkFhTCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnaW5hdGlvbk1vZGVsIH0gZnJvbSBcIi4uL3BhZ2luYXRpb24tbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgRXhwZXJpbWVudGFsU2VydmljZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2V4cGVyaW1lbnRhbFwiO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jb21tb25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uTmF2VHJhbnNsYXRpb25zIHtcblx0TkVYVDogc3RyaW5nO1xuXHRQUkVWSU9VUzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFVzZSBwYWdpbmF0aW9uIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgcGFnZXMgb2YgZGF0YSB0byBoYW5kbGUuXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1wYWdpbmF0aW9uLW5hdi0tYmFzaWMpXG4gKlxuICogYGBgaHRtbFxuICogPGlibS1wYWdpbmF0aW9uLW5hdiBbbW9kZWxdPVwibW9kZWxcIiAoc2VsZWN0UGFnZSk9XCJzZWxlY3RQYWdlKCRldmVudClcIj48L2libS1wYWdpbmF0aW9uLW5hdj5cbiAqIGBgYFxuICpcbiAqIEluIHlvdXIgYHNlbGVjdFBhZ2UoKWAgbWV0aG9kIHNldCB0aGUgYG1vZGVsLmN1cnJlbnRQYWdlYCB0byBzZWxlY3RlZCBwYWdlLCBfYWZ0ZXJfXG4gKiB5b3UgbG9hZCB0aGUgcGFnZS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZWxlY3RQYWdlKHBhZ2UpIHtcbiAqIFx0Ly8gLi4uIHlvdXIgY29kZSB0byBsb2FkIHRoZSBwYWdlIGdvZXMgaGVyZVxuICpcbiAqIFx0dGhpcy5tb2RlbC5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gKlxuICogXHQvLyAuLi4gYW55dGhpbmcgeW91IHdhbnQgdG8gZG8gYWZ0ZXIgcGFnZSBzZWxlY3Rpb24gY2hhbmdlcyBnb2VzIGhlcmVcbiAqIH1cbiAqIGBgYFxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD1jb21wb25lbnRzLXBhZ2luYXRpb24tbmF2LS1iYXNpYzwvZXhhbXBsZS11cmw+XG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tcGFnaW5hdGlvbi1uYXZcIixcblx0dGVtcGxhdGU6IGBcblx0PGRpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiYngtLXBhZ2luYXRpb24tbmF2XCI+XG5cdFx0XHQ8dWwgY2xhc3M9XCJieC0tcGFnaW5hdGlvbi1uYXZfX2xpc3RcIj5cblx0XHRcdFx0PGxpIGNsYXNzPVwiYngtLXBhZ2luYXRpb24tbmF2X19saXN0LWl0ZW1cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1idG4gYngtLWJ0bi0tZ2hvc3QgYngtLXBhZ2luYXRpb24tbmF2LXByZXZpb3VzXG5cdFx0XHRcdFx0XHRieC0tYnRuLS1pY29uLW9ubHkgYngtLXRvb2x0aXBfX3RyaWdnZXIgYngtLXRvb2x0aXAtLWExMXkgYngtLXRvb2x0aXAtLWJvdHRvbSBieC0tdG9vbHRpcC0tYWxpZ24tY2VudGVyXCJcblx0XHRcdFx0XHRcdFtkaXNhYmxlZF09XCJsZWZ0QXJyb3dEaXNhYmxlZFwiXG5cdFx0XHRcdFx0XHQoY2xpY2spPVwianVtcFRvUHJldmlvdXMoKVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJieC0tYXNzaXN0aXZlLXRleHRcIj57e3ByZXZpb3VzSXRlbVRleHQuc3ViamVjdCB8IGFzeW5jfX08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0XHRcdGlibUljb249XCJjYXJldC0tbGVmdFwiXG5cdFx0XHRcdFx0XHRcdHNpemU9XCIxNlwiXG5cdFx0XHRcdFx0XHRcdHN0eWxlPVwiZGlzcGxheTogaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiYngtLWJ0bl9faWNvblwiPlxuXHRcdFx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHRcdDxpYm0tcGFnaW5hdGlvbi1uYXYtaXRlbVxuXHRcdFx0XHRcdCpuZ0lmPVwidGhpcy5udW1PZkl0ZW1zVG9TaG93ID49IDUgfHwgKHRoaXMubnVtT2ZJdGVtc1RvU2hvdyA8PSA0ICYmIGN1cnJlbnRQYWdlIDw9IDEpXCJcblx0XHRcdFx0XHRwYWdlPVwiMVwiXG5cdFx0XHRcdFx0KGNsaWNrKT1cImN1cnJlbnRQYWdlID0gMVwiXG5cdFx0XHRcdFx0W2lzQWN0aXZlXT1cImN1cnJlbnRQYWdlID09IDFcIj5cblx0XHRcdFx0PC9pYm0tcGFnaW5hdGlvbi1uYXYtaXRlbT5cblx0XHRcdFx0PGlibS1wYWdpbmF0aW9uLW92ZXJmbG93XG5cdFx0XHRcdFx0Km5nSWY9XCJmcm9udEN1dHNcIlxuXHRcdFx0XHRcdFtjb3VudF09XCJmcm9udEN1dHNcIlxuXHRcdFx0XHRcdFtmcm9tSW5kZXhdPVwic3RhcnRPZmZzZXRcIlxuXHRcdFx0XHRcdChjaGFuZ2UpPVwiaGFuZGxlT3ZlcmZsb3dTZWxlY3Rpb24oJGV2ZW50KVwiPlxuXHRcdFx0XHQ8L2libS1wYWdpbmF0aW9uLW92ZXJmbG93PlxuXHRcdFx0XHQ8aWJtLXBhZ2luYXRpb24tbmF2LWl0ZW1cblx0XHRcdFx0XHQqbmdGb3I9XCJsZXQgcGFnZSBvZiBnZXRQYWdlcygpO1wiXG5cdFx0XHRcdFx0W3BhZ2VdPVwicGFnZVwiXG5cdFx0XHRcdFx0KGNsaWNrKT1cImN1cnJlbnRQYWdlID0gcGFnZVwiXG5cdFx0XHRcdFx0W2lzQWN0aXZlXT1cImN1cnJlbnRQYWdlID09IHBhZ2VcIj5cblx0XHRcdFx0PC9pYm0tcGFnaW5hdGlvbi1uYXYtaXRlbT5cblx0XHRcdFx0PGlibS1wYWdpbmF0aW9uLW92ZXJmbG93XG5cdFx0XHRcdFx0Km5nSWY9XCJiYWNrQ3V0c1wiXG5cdFx0XHRcdFx0W2NvdW50XT1cImJhY2tDdXRzXCJcblx0XHRcdFx0XHRbZnJvbUluZGV4XT1cInRvdGFsTnVtYmVyc0FycmF5Lmxlbmd0aCAtIGJhY2tDdXRzIC0gMVwiXG5cdFx0XHRcdFx0KGNoYW5nZSk9XCJoYW5kbGVPdmVyZmxvd1NlbGVjdGlvbigkZXZlbnQpXCI+XG5cdFx0XHRcdDwvaWJtLXBhZ2luYXRpb24tb3ZlcmZsb3c+XG5cdFx0XHRcdDxpYm0tcGFnaW5hdGlvbi1uYXYtaXRlbVxuXHRcdFx0XHRcdCpuZ0lmPVwidG90YWxEYXRhTGVuZ3RoID4gMVwiXG5cdFx0XHRcdFx0W3BhZ2VdPVwidG90YWxOdW1iZXJzQXJyYXkubGVuZ3RoXCJcblx0XHRcdFx0XHQoY2xpY2spPVwiY3VycmVudFBhZ2UgPSB0b3RhbE51bWJlcnNBcnJheS5sZW5ndGhcIlxuXHRcdFx0XHRcdFtpc0FjdGl2ZV09XCJjdXJyZW50UGFnZSA9PSB0b3RhbE51bWJlcnNBcnJheS5sZW5ndGhcIj5cblx0XHRcdFx0PC9pYm0tcGFnaW5hdGlvbi1uYXYtaXRlbT5cblx0XHRcdFx0PGxpIGNsYXNzPVwiYngtLXBhZ2luYXRpb24tbmF2X19saXN0LWl0ZW1cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1idG4gYngtLWJ0bi0tZ2hvc3QgYngtLXBhZ2luYXRpb24tbmF2LW5leHRcblx0XHRcdFx0XHRcdGJ4LS1idG4tLWljb24tb25seSBieC0tdG9vbHRpcF9fdHJpZ2dlciBieC0tdG9vbHRpcC0tYTExeSBieC0tdG9vbHRpcC0tYm90dG9tIGJ4LS10b29sdGlwLS1hbGlnbi1jZW50ZXJcIlxuXHRcdFx0XHRcdFx0W2Rpc2FibGVkXT1cInJpZ2h0QXJyb3dEaXNhYmxlZFwiXG5cdFx0XHRcdFx0XHQoY2xpY2spPVwianVtcFRvTmV4dCgpXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS1hc3Npc3RpdmUtdGV4dFwiPnt7bmV4dEl0ZW1UZXh0LnN1YmplY3QgfCBhc3luY319PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdFx0XHRpYm1JY29uPVwiY2FyZXQtLXJpZ2h0XCJcblx0XHRcdFx0XHRcdFx0c2l6ZT1cIjE2XCJcblx0XHRcdFx0XHRcdFx0c3R5bGU9XCJkaXNwbGF5OiBpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJieC0tYnRuX19pY29uXCI+XG5cdFx0XHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdDwvdWw+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuXHRgXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2luYXRpb25OYXYge1xuXHRzdGF0aWMgcGFnaW5hdGlvbkNvdW50ZXIgPSAwO1xuXHQvKipcblx0ICogYFBhZ2luYXRpb25OYXZNb2RlbGAgd2l0aCB0aGUgaW5mb3JtYXRpb24gYWJvdXQgcGFnZXMgeW91J3JlIGNvbnRyb2xsaW5nLlxuXHQgKi9cblx0QElucHV0KCkgbW9kZWw6IFBhZ2luYXRpb25Nb2RlbDtcblx0LyoqXG4gXHQgKiBTZXQgdG8gYHRydWVgIHRvIGRpc2FibGUgdGhlIGJhY2t3YXJkL2ZvcndhcmQgYnV0dG9ucy5cblx0ICovXG5cdEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgaXRlbXMgdG8gc2hvdyBpbiBwYWdpbmF0aW9uLiBNaW5pbXVtIGlzIDQuXG5cdCAqL1xuXHRASW5wdXQoKSBudW1PZkl0ZW1zVG9TaG93ID0gNDtcblxuXHQvKipcblx0ICogRXhwZWN0cyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBzb21lIG9yIGFsbCBvZjpcblx0ICogYGBgXG5cdCAqIHtcblx0ICpcdFx0XCJORVhUXCI6IFwiTmV4dFwiLFxuXHQgKlx0XHRcIlBSRVZJT1VTXCI6IFwiUHJldmlvdXNcIixcblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCB0cmFuc2xhdGlvbnMgKHZhbHVlOiBQYWdpbmF0aW9uTmF2VHJhbnNsYXRpb25zKSB7XG5cdFx0Y29uc3QgdmFsdWVXaXRoRGVmYXVsdHMgPSBtZXJnZSh0aGlzLmkxOG4uZ2V0TXVsdGlwbGUoXCJQQUdJTkFUSU9OXCIpLCB2YWx1ZSk7XG5cdFx0dGhpcy5uZXh0SXRlbVRleHQub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuTkVYVCk7XG5cdFx0dGhpcy5wcmV2aW91c0l0ZW1UZXh0Lm92ZXJyaWRlKHZhbHVlV2l0aERlZmF1bHRzLlBSRVZJT1VTKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyB0aGUgbmV3IHBhZ2UgbnVtYmVyLlxuXHQgKlxuXHQgKiBZb3Ugc2hvdWxkIHRpZSBpbnRvIHRoaXMgYW5kIHVwZGF0ZSBgbW9kZWwuY3VycmVudFBhZ2VgIG9uY2UgdGhlIGZyZXNoXG5cdCAqIGRhdGEgaXMgZmluYWxseSBsb2FkZWQuXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0UGFnZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG5cdGdldCB0b3RhbE51bWJlcnNBcnJheSgpIHtcblx0XHRyZXR1cm4gcmFuZ2UodGhpcy50b3RhbERhdGFMZW5ndGggKyAxLCAxKTtcblx0fVxuXG5cdGdldCBjdXJyZW50UGFnZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5tb2RlbC5jdXJyZW50UGFnZTtcblx0fVxuXG5cdHNldCBjdXJyZW50UGFnZSh2YWx1ZSkge1xuXHRcdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0XHQvLyBlbWl0cyB0aGUgdmFsdWUgdG8gYWxsb3cgdGhlIHVzZXIgdG8gdXBkYXRlIGN1cnJlbnQgcGFnZVxuXHRcdC8vIGluIHRoZSBtb2RlbCBvbmNlIHRoZSBwYWdlIGlzIGxvYWRlZFxuXHRcdHRoaXMuc2VsZWN0UGFnZS5lbWl0KHZhbHVlKTtcblx0fVxuXG5cdGdldCB0b3RhbERhdGFMZW5ndGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMubW9kZWwudG90YWxEYXRhTGVuZ3RoO1xuXHR9XG5cblx0Z2V0IHN0YXJ0T2Zmc2V0KCkge1xuXHRcdHJldHVybiB0aGlzLm51bU9mSXRlbXNUb1Nob3cgPD0gNCAmJiB0aGlzLmN1cnJlbnRQYWdlID4gMSA/IDAgOiAxO1xuXHR9XG5cblx0Z2V0IGZyb250Q3V0cygpIHtcblx0XHRjb25zdCBjdXRzID0gdGhpcy5nZXRDdXRzKCk7XG5cdFx0cmV0dXJuIGN1dHMuZnJvbnQ7XG5cdH1cblxuXHRnZXQgYmFja0N1dHMoKSB7XG5cdFx0Y29uc3QgY3V0cyA9IHRoaXMuZ2V0Q3V0cygpO1xuXHRcdHJldHVybiBjdXRzLmJhY2s7XG5cdH1cblxuXHRnZXQgbGVmdEFycm93RGlzYWJsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5jdXJyZW50UGFnZSA9PT0gMTtcblx0fVxuXG5cdGdldCByaWdodEFycm93RGlzYWJsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5jdXJyZW50UGFnZSA9PT0gdGhpcy50b3RhbERhdGFMZW5ndGg7XG5cdH1cblxuXHRuZXh0SXRlbVRleHQgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJQQUdJTkFUSU9OLk5FWFRcIik7XG5cdHByZXZpb3VzSXRlbVRleHQgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJQQUdJTkFUSU9OLlBSRVZJT1VTXCIpO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpMThuOiBJMThuLCBwcm90ZWN0ZWQgZXhwZXJpbWVudGFsOiBFeHBlcmltZW50YWxTZXJ2aWNlKSB7XG5cdFx0UGFnaW5hdGlvbk5hdi5wYWdpbmF0aW9uQ291bnRlcisrO1xuXHR9XG5cblx0aGFuZGxlT3ZlcmZsb3dTZWxlY3Rpb24ocGFnZSkge1xuXHRcdGlmICh0eXBlb2YgcGFnZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0dGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGp1bXBUb05leHQoKSB7XG5cdFx0dGhpcy5jdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2UgPCB0aGlzLnRvdGFsRGF0YUxlbmd0aCA/IHRoaXMuY3VycmVudFBhZ2UgKyAxIDogdGhpcy50b3RhbERhdGFMZW5ndGg7XG5cdH1cblxuXHRwdWJsaWMganVtcFRvUHJldmlvdXMoKSB7XG5cdFx0dGhpcy5jdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2UgPiAxID8gdGhpcy5jdXJyZW50UGFnZSAtIDEgOiAxO1xuXHR9XG5cblx0cHVibGljIGdldFBhZ2VzKCkge1xuXHRcdGlmICh0aGlzLnRvdGFsRGF0YUxlbmd0aCA8PSAxKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Y29uc3QgY3V0cyA9IHRoaXMuZ2V0Q3V0cygpO1xuXHRcdHJldHVybiB0aGlzLnRvdGFsTnVtYmVyc0FycmF5LnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQgKyBjdXRzLmZyb250LCAoMSArIGN1dHMuYmFjaykgKiAtMSk7XG5cdH1cblxuXHRwcml2YXRlIGdldEN1dHMoc3BsaXRQb2ludCA9IG51bGwpIHtcblx0XHRjb25zdCBwYWdlID0gdGhpcy5jdXJyZW50UGFnZSAtIDE7XG5cdFx0Y29uc3QgdG90YWxJdGVtcyA9IHRoaXMudG90YWxEYXRhTGVuZ3RoO1xuXHRcdGNvbnN0IGl0ZW1zVGhhdEZpdCA9IHRoaXMubnVtT2ZJdGVtc1RvU2hvdztcblxuXHRcdGlmIChpdGVtc1RoYXRGaXQgPj0gdG90YWxJdGVtcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZnJvbnQ6IDAsXG5cdFx0XHRcdGJhY2s6IDBcblx0XHRcdH07XG5cdFx0fVxuXHRcdGNvbnN0IHNwbGl0ID0gc3BsaXRQb2ludCB8fCBNYXRoLmNlaWwoaXRlbXNUaGF0Rml0IC8gMikgLSAxO1xuXHRcdGxldCBmcm9udEhpZGRlbiA9IHBhZ2UgKyAxIC0gc3BsaXQ7XG5cdFx0bGV0IGJhY2tIaWRkZW4gPSB0b3RhbEl0ZW1zIC0gcGFnZSAtIChpdGVtc1RoYXRGaXQgLSBzcGxpdCkgKyAxO1xuXG5cdFx0aWYgKGZyb250SGlkZGVuIDw9IDEpIHtcblx0XHRcdGJhY2tIaWRkZW4gLT0gZnJvbnRIaWRkZW4gPD0gMCA/IE1hdGguYWJzKGZyb250SGlkZGVuKSArIDEgOiAwO1xuXHRcdFx0ZnJvbnRIaWRkZW4gPSAwO1xuXHRcdH1cblx0XHRpZiAoYmFja0hpZGRlbiA8PSAxKSB7XG5cdFx0XHRmcm9udEhpZGRlbiAtPSBiYWNrSGlkZGVuIDw9IDAgPyBNYXRoLmFicyhiYWNrSGlkZGVuKSArIDEgOiAwO1xuXHRcdFx0YmFja0hpZGRlbiA9IDA7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRmcm9udDogZnJvbnRIaWRkZW4sXG5cdFx0XHRiYWNrOiBiYWNrSGlkZGVuXG5cdFx0fTtcblx0fVxufVxuIl19