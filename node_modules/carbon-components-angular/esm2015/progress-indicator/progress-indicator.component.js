/**
 *
 * carbon-angular v0.0.0 | progress-indicator.component.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, Output, EventEmitter } from "@angular/core";
import { ExperimentalService } from "carbon-components-angular/experimental";
/**
 * [See demo](../../?path=/story/components-progress-indicator--basic)
 *
 * <example-url>../../iframe.html?id=components-progress-indicator--basic</example-url>
 */
export class ProgressIndicator {
    constructor(experimental) {
        this.experimental = experimental;
        this.stepSelected = new EventEmitter();
        this.orientation = "horizontal";
        this.skeleton = false;
        this.spacing = "default";
    }
    static skeletonSteps(stepCount) {
        const steps = [];
        for (let i = 0; i < stepCount; i++) {
            steps.push({ "state": ["incomplete"] });
        }
        return steps;
    }
    get current() {
        return this.steps.findIndex(step => step.state.includes("current"));
    }
    set current(current) {
        this._current = current;
    }
    ngOnChanges(changes) {
        if (changes.steps || changes.current) {
            this.setProgressIndicatorStates();
        }
    }
    setProgressIndicatorStates() {
        if (this.steps === undefined) {
            return;
        }
        if (this._current === undefined || this._current < 0) {
            for (let i = 0; i < this.steps.length; i++) {
                this.steps[i].state[0] = "incomplete";
            }
            return;
        }
        if (this._current > this.steps.length - 1) {
            for (let i = 0; i < this.steps.length; i++) {
                this.steps[i].state[0] = "complete";
            }
            return;
        }
        this.steps[this._current].state[0] = "current";
        for (let i = 0; i < this._current; i++) {
            this.steps[i].state[0] = "complete";
        }
        for (let i = this._current + 1; i < this.steps.length; i++) {
            this.steps[i].state[0] = "incomplete";
        }
    }
}
ProgressIndicator.decorators = [
    { type: Component, args: [{
                selector: "ibm-progress-indicator",
                template: `
	<ul
		data-progress
		data-progress-current
		class="bx--progress"
		[ngClass]="{
			'bx--skeleton': skeleton,
			'bx--progress--vertical': (orientation === 'vertical'),
			'bx--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="bx--progress-step bx--progress-step--{{step.state[0]}}"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{'bx--progress-step--disabled' : step.disabled}">
			<div class="bx--progress-step-button bx--progress-step-button--unclickable" role="button" tabindex="-1">
				<svg ibmIcon="checkmark--outline" size="16" *ngIf="step.state.includes('complete')"></svg>
				<svg *ngIf="step.state.includes('current')">
					<path d="M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0" ></path>
				</svg>
				<svg *ngIf="step.state.includes('incomplete')">
					<path
						d="M8 1C4.1 1 1 4.1 1 8s3.1 7 7 7 7-3.1 7-7-3.1-7-7-7zm0 13c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z">
					</path>
				</svg>
				<svg ibmIcon="warning" size="16" *ngIf="step.state.includes('error')" class="bx--progress__warning"></svg>
				<p
					class="bx--progress-label"
					*ngIf="step.tooltip"
					[ibmTooltip]="step.tooltip.content"
					[trigger]="step.tooltip.trigger"
					[placement]="step.tooltip.placement"
					[title]="step.tooltip.title"
					[gap]="step.tooltip.gap"
					[appendInline]="step.tooltip.appendInline"
					[data]="step.tooltip.data"
					(click)="stepSelected.emit({ step: step, index: i })">
					{{step.text}}
				</p>
				<p class="bx--progress-label" *ngIf="!step.tooltip" (click)="stepSelected.emit({ step: step, index: i })">{{step.text}}</p>
				<p *ngIf="step.optionalText" class="bx--progress-optional">{{step.optionalText}}</p>
				<span class="bx--progress-line"></span>
			</div>
		</li>
	</ul>
	`
            }] }
];
/** @nocollapse */
ProgressIndicator.ctorParameters = () => [
    { type: ExperimentalService }
];
ProgressIndicator.propDecorators = {
    stepSelected: [{ type: Output }],
    steps: [{ type: Input }],
    orientation: [{ type: Input }],
    skeleton: [{ type: Input }],
    spacing: [{ type: Input }],
    current: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvcHJvZ3Jlc3MtaW5kaWNhdG9yLyIsInNvdXJjZXMiOlsicHJvZ3Jlc3MtaW5kaWNhdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBRzdFOzs7O0dBSUc7QUFpREgsTUFBTSxPQUFPLGlCQUFpQjtJQXlCN0IsWUFBc0IsWUFBaUM7UUFBakMsaUJBQVksR0FBWixZQUFZLENBQXFCO1FBZjdDLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQWlDLENBQUM7UUFHbEUsZ0JBQVcsR0FBOEIsWUFBWSxDQUFDO1FBQ3RELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsWUFBTyxHQUF3QixTQUFTLENBQUM7SUFVUSxDQUFDO0lBeEIzRCxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQWlCO1FBQ3JDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25DLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBQyxDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFTRCxJQUFhLE9BQU87UUFDbkIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLE9BQWU7UUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7SUFDekIsQ0FBQztJQUtELFdBQVcsQ0FBQyxPQUFzQjtRQUNqQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUNyQyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztTQUNsQztJQUNGLENBQUM7SUFFTywwQkFBMEI7UUFDakMsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUM3QixPQUFPO1NBQ1A7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFO1lBQ3JELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDM0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDO2FBQ3RDO1lBQ0QsT0FBTztTQUNQO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzNDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQzthQUNwQztZQUNELE9BQU87U0FDUDtRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7UUFDL0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1NBQ3BDO1FBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDM0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDO1NBQ3RDO0lBQ0YsQ0FBQzs7O1lBMUdELFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsd0JBQXdCO2dCQUNsQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNENUO2FBQ0Q7Ozs7WUF2RFEsbUJBQW1COzs7MkJBa0UxQixNQUFNO29CQUVOLEtBQUs7MEJBQ0wsS0FBSzt1QkFDTCxLQUFLO3NCQUNMLEtBQUs7c0JBRUwsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEV4cGVyaW1lbnRhbFNlcnZpY2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9leHBlcmltZW50YWxcIjtcbmltcG9ydCB7IFN0ZXAgfSBmcm9tIFwiLi9wcm9ncmVzcy1pbmRpY2F0b3Itc3RlcC5pbnRlcmZhY2VcIjtcblxuLyoqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLXByb2dyZXNzLWluZGljYXRvci0tYmFzaWMpXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNvbXBvbmVudHMtcHJvZ3Jlc3MtaW5kaWNhdG9yLS1iYXNpYzwvZXhhbXBsZS11cmw+XG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogXCJpYm0tcHJvZ3Jlc3MtaW5kaWNhdG9yXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDx1bFxuXHRcdGRhdGEtcHJvZ3Jlc3Ncblx0XHRkYXRhLXByb2dyZXNzLWN1cnJlbnRcblx0XHRjbGFzcz1cImJ4LS1wcm9ncmVzc1wiXG5cdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0J2J4LS1za2VsZXRvbic6IHNrZWxldG9uLFxuXHRcdFx0J2J4LS1wcm9ncmVzcy0tdmVydGljYWwnOiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpLFxuXHRcdFx0J2J4LS1wcm9ncmVzcy0tc3BhY2UtZXF1YWwnOiBzcGFjaW5nID09PSAnZXF1YWwnICYmIG9yaWVudGF0aW9uICE9PSAndmVydGljYWwnXG5cdFx0fVwiPlxuXHRcdDxsaVxuXHRcdFx0Y2xhc3M9XCJieC0tcHJvZ3Jlc3Mtc3RlcCBieC0tcHJvZ3Jlc3Mtc3RlcC0te3tzdGVwLnN0YXRlWzBdfX1cIlxuXHRcdFx0Km5nRm9yPVwibGV0IHN0ZXAgb2Ygc3RlcHM7IGxldCBpID0gaW5kZXhcIlxuXHRcdFx0W25nQ2xhc3NdPVwieydieC0tcHJvZ3Jlc3Mtc3RlcC0tZGlzYWJsZWQnIDogc3RlcC5kaXNhYmxlZH1cIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tcHJvZ3Jlc3Mtc3RlcC1idXR0b24gYngtLXByb2dyZXNzLXN0ZXAtYnV0dG9uLS11bmNsaWNrYWJsZVwiIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIi0xXCI+XG5cdFx0XHRcdDxzdmcgaWJtSWNvbj1cImNoZWNrbWFyay0tb3V0bGluZVwiIHNpemU9XCIxNlwiICpuZ0lmPVwic3RlcC5zdGF0ZS5pbmNsdWRlcygnY29tcGxldGUnKVwiPjwvc3ZnPlxuXHRcdFx0XHQ8c3ZnICpuZ0lmPVwic3RlcC5zdGF0ZS5pbmNsdWRlcygnY3VycmVudCcpXCI+XG5cdFx0XHRcdFx0PHBhdGggZD1cIk0gNywgNyBtIC03LCAwIGEgNyw3IDAgMSwwIDE0LDAgYSA3LDcgMCAxLDAgLTE0LDBcIiA+PC9wYXRoPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0PHN2ZyAqbmdJZj1cInN0ZXAuc3RhdGUuaW5jbHVkZXMoJ2luY29tcGxldGUnKVwiPlxuXHRcdFx0XHRcdDxwYXRoXG5cdFx0XHRcdFx0XHRkPVwiTTggMUM0LjEgMSAxIDQuMSAxIDhzMy4xIDcgNyA3IDctMy4xIDctNy0zLjEtNy03LTd6bTAgMTNjLTMuMyAwLTYtMi43LTYtNnMyLjctNiA2LTYgNiAyLjcgNiA2LTIuNyA2LTYgNnpcIj5cblx0XHRcdFx0XHQ8L3BhdGg+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8c3ZnIGlibUljb249XCJ3YXJuaW5nXCIgc2l6ZT1cIjE2XCIgKm5nSWY9XCJzdGVwLnN0YXRlLmluY2x1ZGVzKCdlcnJvcicpXCIgY2xhc3M9XCJieC0tcHJvZ3Jlc3NfX3dhcm5pbmdcIj48L3N2Zz5cblx0XHRcdFx0PHBcblx0XHRcdFx0XHRjbGFzcz1cImJ4LS1wcm9ncmVzcy1sYWJlbFwiXG5cdFx0XHRcdFx0Km5nSWY9XCJzdGVwLnRvb2x0aXBcIlxuXHRcdFx0XHRcdFtpYm1Ub29sdGlwXT1cInN0ZXAudG9vbHRpcC5jb250ZW50XCJcblx0XHRcdFx0XHRbdHJpZ2dlcl09XCJzdGVwLnRvb2x0aXAudHJpZ2dlclwiXG5cdFx0XHRcdFx0W3BsYWNlbWVudF09XCJzdGVwLnRvb2x0aXAucGxhY2VtZW50XCJcblx0XHRcdFx0XHRbdGl0bGVdPVwic3RlcC50b29sdGlwLnRpdGxlXCJcblx0XHRcdFx0XHRbZ2FwXT1cInN0ZXAudG9vbHRpcC5nYXBcIlxuXHRcdFx0XHRcdFthcHBlbmRJbmxpbmVdPVwic3RlcC50b29sdGlwLmFwcGVuZElubGluZVwiXG5cdFx0XHRcdFx0W2RhdGFdPVwic3RlcC50b29sdGlwLmRhdGFcIlxuXHRcdFx0XHRcdChjbGljayk9XCJzdGVwU2VsZWN0ZWQuZW1pdCh7IHN0ZXA6IHN0ZXAsIGluZGV4OiBpIH0pXCI+XG5cdFx0XHRcdFx0e3tzdGVwLnRleHR9fVxuXHRcdFx0XHQ8L3A+XG5cdFx0XHRcdDxwIGNsYXNzPVwiYngtLXByb2dyZXNzLWxhYmVsXCIgKm5nSWY9XCIhc3RlcC50b29sdGlwXCIgKGNsaWNrKT1cInN0ZXBTZWxlY3RlZC5lbWl0KHsgc3RlcDogc3RlcCwgaW5kZXg6IGkgfSlcIj57e3N0ZXAudGV4dH19PC9wPlxuXHRcdFx0XHQ8cCAqbmdJZj1cInN0ZXAub3B0aW9uYWxUZXh0XCIgY2xhc3M9XCJieC0tcHJvZ3Jlc3Mtb3B0aW9uYWxcIj57e3N0ZXAub3B0aW9uYWxUZXh0fX08L3A+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYngtLXByb2dyZXNzLWxpbmVcIj48L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2xpPlxuXHQ8L3VsPlxuXHRgXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzSW5kaWNhdG9yIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblx0c3RhdGljIHNrZWxldG9uU3RlcHMoc3RlcENvdW50OiBudW1iZXIpIHtcblx0XHRjb25zdCBzdGVwcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcENvdW50OyBpKyspIHtcblx0XHRcdHN0ZXBzLnB1c2goe1wic3RhdGVcIjogW1wiaW5jb21wbGV0ZVwiXX0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdGVwcztcblx0fVxuXG5cdEBPdXRwdXQoKSBzdGVwU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHsgc3RlcDogU3RlcCwgaW5kZXg6IG51bWJlciB9PigpO1xuXG5cdEBJbnB1dCgpIHN0ZXBzOiBBcnJheTxTdGVwPjtcblx0QElucHV0KCkgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiID0gXCJob3Jpem9udGFsXCI7XG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cdEBJbnB1dCgpIHNwYWNpbmc6IFwiZGVmYXVsdFwiIHwgXCJlcXVhbFwiID0gXCJkZWZhdWx0XCI7XG5cblx0QElucHV0KCkgZ2V0IGN1cnJlbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlcHMuZmluZEluZGV4KHN0ZXAgPT4gc3RlcC5zdGF0ZS5pbmNsdWRlcyhcImN1cnJlbnRcIikpO1xuXHR9XG5cdHNldCBjdXJyZW50KGN1cnJlbnQ6IG51bWJlcikge1xuXHRcdHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuXHR9XG5cdHByaXZhdGUgX2N1cnJlbnQ6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZXhwZXJpbWVudGFsOiBFeHBlcmltZW50YWxTZXJ2aWNlKSB7fVxuXG5cdG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcblx0XHRpZiAoY2hhbmdlcy5zdGVwcyB8fCBjaGFuZ2VzLmN1cnJlbnQpIHtcblx0XHRcdHRoaXMuc2V0UHJvZ3Jlc3NJbmRpY2F0b3JTdGF0ZXMoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHNldFByb2dyZXNzSW5kaWNhdG9yU3RhdGVzKCkge1xuXHRcdGlmICh0aGlzLnN0ZXBzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fY3VycmVudCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2N1cnJlbnQgPCAwKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5zdGVwc1tpXS5zdGF0ZVswXSA9IFwiaW5jb21wbGV0ZVwiO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9jdXJyZW50ID4gdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5zdGVwc1tpXS5zdGF0ZVswXSA9IFwiY29tcGxldGVcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5zdGVwc1t0aGlzLl9jdXJyZW50XS5zdGF0ZVswXSA9IFwiY3VycmVudFwiO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY3VycmVudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnN0ZXBzW2ldLnN0YXRlWzBdID0gXCJjb21wbGV0ZVwiO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gdGhpcy5fY3VycmVudCArIDE7IGkgPCB0aGlzLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnN0ZXBzW2ldLnN0YXRlWzBdID0gXCJpbmNvbXBsZXRlXCI7XG5cdFx0fVxuXHR9XG59XG4iXX0=