/**
 *
 * carbon-angular v0.0.0 | table-model.class.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { EventEmitter } from "@angular/core";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { Subject } from "rxjs";
/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
export class TableModel {
    constructor() {
        this.dataChange = new EventEmitter();
        this.rowsSelectedChange = new EventEmitter();
        this.rowsExpandedChange = new EventEmitter();
        /**
         * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
         * all rows are selected.
         */
        this.selectAllChange = new Subject();
        /**
         * Contains information about selection state of rows in the table.
         */
        this.rowsSelected = [];
        /**
         * Contains information about expanded state of rows in the table.
         */
        this.rowsExpanded = [];
        /**
         * Contains information about the context of the row.
         *
         * It affects styling of the row to reflect the context.
         *
         * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
         * empty or undefined by default
         */
        this.rowsContext = [];
        /**
         * Contains class name(s) of the row.
         *
         * It affects styling of the row to reflect the appended class name(s).
         *
         * It's empty or undefined by default
         */
        this.rowsClass = [];
        /**
         * Contains information about the header cells of the table.
         */
        this.header = [];
        /**
         * Tracks the current page.
         */
        this.currentPage = 1;
        /**
         * Length of page.
         */
        this.pageLength = 10;
        /**
         * Set to true when there is no more data to load in the table
         */
        this.isEnd = false;
        /**
         * Set to true when lazy loading to show loading indicator
         */
        this.isLoading = false;
        /**
         * Used in `data`
         */
        this._data = [[]];
        /**
         * The number of models instantiated, this is to make sure each table has a different
         * model count for unique id generation.
         */
        this.tableModelCount = 0;
        this.tableModelCount = TableModel.COUNT++;
    }
    /**
     * Sets data of the table.
     *
     * Make sure all rows are the same length to keep the column count accurate.
     */
    set data(newData) {
        if (!newData || (Array.isArray(newData) && newData.length === 0)) {
            newData = [[]];
        }
        this._data = newData;
        // init rowsSelected
        this.rowsSelected = new Array(this._data.length).fill(false);
        this.rowsExpanded = new Array(this._data.length).fill(false);
        // init rowsContext
        this.rowsContext = new Array(this._data.length);
        // init rowsClass
        this.rowsClass = new Array(this._data.length);
        // only create a fresh header if necessary (header doesn't exist or differs in length)
        if (this.header == null || (this.header.length !== this._data[0].length && this._data[0].length > 0)) {
            let header = new Array();
            for (let i = 0; i < this._data[0].length; i++) {
                header.push(new TableHeaderItem());
            }
            this.header = header;
        }
        this.dataChange.emit();
    }
    /**
     * Gets the full data.
     *
     * You can use it to alter individual `TableItem`s but if you need to change
     * table structure, use `addRow()` and/or `addColumn()`
     */
    get data() {
        return this._data;
    }
    /**
     * Manually set data length in case the data in the table doesn't
     * correctly reflect all the data that table is to display.
     *
     * Example: if you have multiple pages of data that table will display
     * but you're loading one at a time.
     *
     * Set to `null` to reset to default behavior.
     */
    set totalDataLength(length) {
        // if this function is called without a parameter we need to set to null to avoid having undefined != null
        this._totalDataLength = isNaN(length) ? null : length;
    }
    /**
     * Total length of data that table has access to, or the amount manually set
     */
    get totalDataLength() {
        // if manually set data length
        if (this._totalDataLength !== null && this._totalDataLength >= 0) {
            return this._totalDataLength;
        }
        // if empty dataset
        if (this.data && this.data.length === 1 && this.data[0].length === 0) {
            return 0;
        }
        return this.data.length;
    }
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    getId(column, row = 0) {
        return `table-header-${row}-${column}-${this.tableModelCount}`;
    }
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    getHeaderId(column, colSpan = 1) {
        if (column === "select" || column === "expand") {
            return this.getId(column);
        }
        let ids = [];
        for (let i = column; i >= 0; i--) {
            if (this.header[i]) {
                for (let j = 0; j < colSpan; j++) {
                    ids.push(this.getId(i + j));
                }
                break;
            }
        }
        return ids.join(" ");
    }
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    getHeader(column) {
        if (!this.header) {
            return null;
        }
        for (let i = column; i >= 0; i--) {
            const headerCell = this.header[i];
            if (headerCell) {
                return headerCell;
            }
        }
        return null;
    }
    /**
     * Returns how many rows is currently selected
     */
    selectedRowsCount() {
        let count = 0;
        if (this.rowsSelected) {
            this.rowsSelected.forEach(rowSelected => {
                if (rowSelected) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns how many rows is currently expanded
     */
    expandedRowsCount() {
        let count = 0;
        if (this.rowsExpanded) {
            this.rowsExpanded.forEach(rowExpanded => {
                if (rowExpanded) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    row(index) {
        return this.data[this.realRowIndex(index)];
    }
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    addRow(row, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            newData.push(row ? row : [new TableItem()]); // row or one empty one column row
            this.data = newData;
            return;
        }
        let realRow = row;
        const columnCount = this.data[0].length;
        if (row == null) {
            realRow = new Array();
            for (let i = 0; i < columnCount; i++) {
                realRow.push(new TableItem());
            }
        }
        if (realRow.length < columnCount) {
            // extend the length of realRow
            const difference = columnCount - realRow.length;
            for (let i = 0; i < difference; i++) {
                realRow.push(new TableItem());
            }
        }
        else if (realRow.length > columnCount) {
            // extend the length of header
            let difference = realRow.length - this.header.length;
            for (let j = 0; j < difference; j++) {
                this.header.push(new TableHeaderItem());
            }
            // extend the length of every other row
            for (let i = 0; i < this.data.length; i++) {
                let currentRow = this.data[i];
                difference = realRow.length - currentRow.length;
                for (let j = 0; j < difference; j++) {
                    currentRow.push(new TableItem());
                }
            }
        }
        if (index == null) {
            this.data.push(realRow);
            // update rowsSelected property for length
            this.rowsSelected.push(false);
            // update rowsExpanded property for length
            this.rowsExpanded.push(false);
            // update rowsContext property for length
            this.rowsContext.push(undefined);
            // update rowsClass property for length
            this.rowsClass.push(undefined);
        }
        else {
            const ri = this.realRowIndex(index);
            this.data.splice(ri, 0, realRow);
            // update rowsSelected property for length
            this.rowsSelected.splice(ri, 0, false);
            // update rowsExpanded property for length
            this.rowsExpanded.splice(ri, 0, false);
            // update rowsContext property for length
            this.rowsContext.splice(ri, 0, undefined);
            // update rowsClass property for length
            this.rowsClass.splice(ri, 0, undefined);
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteRow(index) {
        const rri = this.realRowIndex(index);
        this.data.splice(rri, 1);
        this.rowsSelected.splice(rri, 1);
        this.rowsExpanded.splice(rri, 1);
        this.rowsContext.splice(rri, 1);
        this.rowsClass.splice(rri, 1);
        this.dataChange.emit();
    }
    hasExpandableRows() {
        return this.data.some(data => data.some(d => d && d.expandedData)); // checking for some in 2D array
    }
    isRowExpandable(index) {
        return this.data[index].some(d => d && d.expandedData);
    }
    isRowExpanded(index) {
        return this.rowsExpanded[index];
    }
    getRowContext(index) {
        return this.rowsContext[index];
    }
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    column(index) {
        let column = new Array();
        const ri = this.realColumnIndex(index);
        const rc = this.data.length;
        for (let i = 0; i < rc; i++) {
            const row = this.data[i];
            column.push(row[ri]);
        }
        return column;
    }
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    addColumn(column, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            if (column == null) {
                newData.push([new TableItem()]);
            }
            else {
                for (let i = 0; i < column.length; i++) {
                    let item = column[i];
                    newData.push([item]);
                }
            }
            this.data = newData;
            return;
        }
        let rc = this.data.length; // row count
        let ci = this.realColumnIndex(index);
        // append missing rows
        for (let i = 0; column != null && i < column.length - rc; i++) {
            this.addRow();
        }
        rc = this.data.length;
        if (index == null) {
            // append to end
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.push(column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.push(new TableHeaderItem());
            }
        }
        else {
            if (index >= this.data[0].length) {
                // if trying to append
                ci++;
            }
            // insert
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.splice(ci, 0, new TableHeaderItem());
            }
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteColumn(index) {
        const rci = this.realColumnIndex(index);
        const rowCount = this.data.length;
        for (let i = 0; i < rowCount; i++) {
            this.data[i].splice(rci, 1);
        }
        // update header if not already set by user
        if (this.header.length > this.data[0].length) {
            this.header.splice(rci, 1);
        }
        this.dataChange.emit();
    }
    moveColumn(indexFrom, indexTo) {
        const headerFrom = this.header[indexFrom];
        this.addColumn(this.column(indexFrom), indexTo);
        this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
        this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
    }
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    sort(index) {
        this.pushRowStateToModelData();
        this.data.sort((a, b) => (this.header[index].descending ? -1 : 1) * this.header[index].compare(a[index], b[index]));
        this.popRowStateFromModelData();
        this.header.forEach(column => column.sorted = false);
        this.header[index].sorted = true;
    }
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    pushRowStateToModelData() {
        for (let i = 0; i < this.data.length; i++) {
            const rowSelectedMark = new TableItem();
            rowSelectedMark.data = this.rowsSelected[i];
            this.data[i].push(rowSelectedMark);
            const rowExpandedMark = new TableItem();
            rowExpandedMark.data = this.rowsExpanded[i];
            this.data[i].push(rowExpandedMark);
            const rowContext = new TableItem();
            rowContext.data = this.rowsContext[i];
            this.data[i].push(rowContext);
            const rowClass = new TableItem();
            rowClass.data = this.rowsClass[i];
            this.data[i].push(rowClass);
        }
    }
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    popRowStateFromModelData() {
        for (let i = 0; i < this.data.length; i++) {
            this.rowsClass[i] = this.data[i].pop().data;
            this.rowsContext[i] = this.data[i].pop().data;
            this.rowsExpanded[i] = !!this.data[i].pop().data;
            this.rowsSelected[i] = !!this.data[i].pop().data;
        }
    }
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    isRowFiltered(index) {
        const realIndex = this.realRowIndex(index);
        return this.header.some((item, i) => item && item.filter(this.row(realIndex)[i]));
    }
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    selectRow(index, value = true) {
        if (this.isRowDisabled(index)) {
            return;
        }
        this.rowsSelected[index] = value;
        this.rowsSelectedChange.emit(index);
    }
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    selectAll(value = true) {
        if (this.data.length >= 1 && this.data[0].length >= 1) {
            for (let i = 0; i < this.rowsSelected.length; i++) {
                this.selectRow(i, value);
            }
        }
        this.selectAllChange.next(value);
    }
    isRowSelected(index) {
        return this.rowsSelected[index];
    }
    /**
     * Checks if row is disabled or not.
     */
    isRowDisabled(index) {
        const row = this.data[index];
        return !!row.disabled;
    }
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    expandRow(index, value = true) {
        this.rowsExpanded[index] = value;
        this.rowsExpandedChange.emit(index);
    }
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realRowIndex(index) {
        return this.realIndex(index, this.data.length);
    }
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realColumnIndex(index) {
        return this.realIndex(index, this.data[0].length);
    }
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    realIndex(index, length) {
        if (index == null) {
            return length - 1;
        }
        else if (index >= 0) {
            return index >= length ? length - 1 : index;
        }
        else {
            return -index >= length ? 0 : length + index;
        }
    }
}
/**
 * The number of models instantiated, used for (among other things) unique id generation
 */
TableModel.COUNT = 0;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtbW9kZWwuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsidGFibGUtbW9kZWwuY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFlBQVksRUFDWixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJL0I7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLE9BQU8sVUFBVTtJQWdLdEI7UUF4SEEsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDaEMsdUJBQWtCLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUNoRCx1QkFBa0IsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBQ2hEOzs7V0FHRztRQUNILG9CQUFlLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQVl6Qzs7V0FFRztRQUNILGlCQUFZLEdBQWMsRUFBRSxDQUFDO1FBRTdCOztXQUVHO1FBQ0gsaUJBQVksR0FBYyxFQUFFLENBQUM7UUFFN0I7Ozs7Ozs7V0FPRztRQUNILGdCQUFXLEdBQWEsRUFBRSxDQUFDO1FBRTNCOzs7Ozs7V0FNRztRQUNILGNBQVMsR0FBYSxFQUFFLENBQUM7UUFFekI7O1dBRUc7UUFDSCxXQUFNLEdBQXNCLEVBQUUsQ0FBQztRQUUvQjs7V0FFRztRQUNILGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBRWhCOztXQUVHO1FBQ0gsZUFBVSxHQUFHLEVBQUUsQ0FBQztRQUVoQjs7V0FFRztRQUNILFVBQUssR0FBRyxLQUFLLENBQUM7UUFFZDs7V0FFRztRQUNILGNBQVMsR0FBRyxLQUFLLENBQUM7UUFzQ2xCOztXQUVHO1FBQ08s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SUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sU0FBUyxDQUFDLEtBQWEsRUFBRSxNQUFjO1FBQ2hELElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtZQUNsQixPQUFPLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEI7YUFBTSxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDdEIsT0FBTyxLQUFLLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7U0FDNUM7YUFBTTtZQUNOLE9BQU8sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7U0FDN0M7SUFDRixDQUFDOztBQXJwQkQ7O0dBRUc7QUFDYyxnQkFBSyxHQUFHLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEV2ZW50RW1pdHRlclxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5pbXBvcnQgeyBQYWdpbmF0aW9uTW9kZWwgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9wYWdpbmF0aW9uXCI7XG5pbXBvcnQgeyBUYWJsZUhlYWRlckl0ZW0gfSBmcm9tIFwiLi90YWJsZS1oZWFkZXItaXRlbS5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVJdGVtIH0gZnJvbSBcIi4vdGFibGUtaXRlbS5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVSb3cgfSBmcm9tIFwiLi90YWJsZS1yb3cuY2xhc3NcIjtcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tIFwicnhqc1wiO1xuXG5leHBvcnQgdHlwZSBIZWFkZXJUeXBlID0gbnVtYmVyIHwgXCJzZWxlY3RcIiB8IFwiZXhwYW5kXCI7XG5cbi8qKlxuICogVGFibGVNb2RlbCByZXByZXNlbnRzIGEgZGF0YSBtb2RlbCBmb3IgdHdvLWRpbWVuc2lvbmFsIGRhdGEuIEl0J3MgdXNlZCBmb3IgYWxsIHRoaW5ncyB0YWJsZVxuICogKHRhYmxlIGNvbXBvbmVudCwgdGFibGUgdG9vbGJhciwgcGFnaW5hdGlvbiwgZXRjKVxuICpcbiAqIFRhYmxlTW9kZWwgbWFuYWdlcyBpdHMgaW50ZXJuYWwgZGF0YSBpbnRlZ3JpdHkgdmVyeSB3ZWxsIGlmIHlvdSB1c2UgdGhlIHByb3ZpZGVkIGhlbHBlclxuICogZnVuY3Rpb25zIGZvciBtb2RpZnlpbmcgcm93cyBhbmQgY29sdW1ucyBhbmQgYXNzaWduaW5nIGhlYWRlciBhbmQgZGF0YSBpbiB0aGF0IG9yZGVyLlxuICpcbiAqIEl0IGFsc28gcHJvdmlkZXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgZGF0YSBzbyB5b3UgY2FuIHJlYWQgYW5kIG1vZGlmeSBpdC5cbiAqIElmIHlvdSBjaGFuZ2UgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZGF0YSAoYnkgZGlyZWN0bHkgcHVzaGluZyBpbnRvIHRoZSBhcnJheXMgb3Igb3RoZXJ3aXNlKSxcbiAqIGtlZXAgaW4gbWluZCB0byBrZWVwIHRoZSBkYXRhIHN0cnVjdHVyZSBpbnRhY3QuXG4gKlxuICogSGVhZGVyIGxlbmd0aCBhbmQgbGVuZ3RoIG9mIGV2ZXJ5IGxpbmUgaW4gdGhlIGRhdGEgc2hvdWxkIGJlIGVxdWFsLlxuICpcbiAqIElmIHRoZXkgYXJlIG5vdCBjb25zaXN0ZW50LCB1bmV4cGVjdGVkIHRoaW5ncyB3aWxsIGhhcHBlbi5cbiAqXG4gKiBVc2UgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyB3aGVuIGluIGRvdWJ0LlxuICovXG5leHBvcnQgY2xhc3MgVGFibGVNb2RlbCBpbXBsZW1lbnRzIFBhZ2luYXRpb25Nb2RlbCB7XG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIG1vZGVscyBpbnN0YW50aWF0ZWQsIHVzZWQgZm9yIChhbW9uZyBvdGhlciB0aGluZ3MpIHVuaXF1ZSBpZCBnZW5lcmF0aW9uXG5cdCAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljIENPVU5UID0gMDtcblxuXHQvKipcblx0ICogU2V0cyBkYXRhIG9mIHRoZSB0YWJsZS5cblx0ICpcblx0ICogTWFrZSBzdXJlIGFsbCByb3dzIGFyZSB0aGUgc2FtZSBsZW5ndGggdG8ga2VlcCB0aGUgY29sdW1uIGNvdW50IGFjY3VyYXRlLlxuXHQgKi9cblx0c2V0IGRhdGEobmV3RGF0YTogVGFibGVJdGVtW11bXSkge1xuXHRcdGlmICghbmV3RGF0YSB8fCAoQXJyYXkuaXNBcnJheShuZXdEYXRhKSAmJiBuZXdEYXRhLmxlbmd0aCA9PT0gMCkgKSB7XG5cdFx0XHRuZXdEYXRhID0gW1tdXTtcblx0XHR9XG5cblx0XHR0aGlzLl9kYXRhID0gbmV3RGF0YTtcblxuXHRcdC8vIGluaXQgcm93c1NlbGVjdGVkXG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWQgPSBuZXcgQXJyYXk8Ym9vbGVhbj4odGhpcy5fZGF0YS5sZW5ndGgpLmZpbGwoZmFsc2UpO1xuXHRcdHRoaXMucm93c0V4cGFuZGVkID0gbmV3IEFycmF5PGJvb2xlYW4+KHRoaXMuX2RhdGEubGVuZ3RoKS5maWxsKGZhbHNlKTtcblxuXHRcdC8vIGluaXQgcm93c0NvbnRleHRcblx0XHR0aGlzLnJvd3NDb250ZXh0ID0gbmV3IEFycmF5PHN0cmluZz4odGhpcy5fZGF0YS5sZW5ndGgpO1xuXG5cdFx0Ly8gaW5pdCByb3dzQ2xhc3Ncblx0XHR0aGlzLnJvd3NDbGFzcyA9IG5ldyBBcnJheTxzdHJpbmc+KHRoaXMuX2RhdGEubGVuZ3RoKTtcblxuXHRcdC8vIG9ubHkgY3JlYXRlIGEgZnJlc2ggaGVhZGVyIGlmIG5lY2Vzc2FyeSAoaGVhZGVyIGRvZXNuJ3QgZXhpc3Qgb3IgZGlmZmVycyBpbiBsZW5ndGgpXG5cdFx0aWYgKHRoaXMuaGVhZGVyID09IG51bGwgfHwgKHRoaXMuaGVhZGVyLmxlbmd0aCAhPT0gdGhpcy5fZGF0YVswXS5sZW5ndGggJiYgdGhpcy5fZGF0YVswXS5sZW5ndGggPiAwKSkge1xuXHRcdFx0bGV0IGhlYWRlciA9IG5ldyBBcnJheTxUYWJsZUhlYWRlckl0ZW0+KCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGFbMF0ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHRkYXRhQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRyb3dzU2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblx0cm93c0V4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cdC8qKlxuXHQgKiBHZXRzIGVtaXR0ZWQgd2hlbiBgc2VsZWN0QWxsYCBpcyBjYWxsZWQuIEVtaXRzIGZhbHNlIGlmIGFsbCByb3dzIGFyZSBkZXNlbGVjdGVkIGFuZCB0cnVlIGlmXG5cdCAqIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cblx0ICovXG5cdHNlbGVjdEFsbENoYW5nZSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZ1bGwgZGF0YS5cblx0ICpcblx0ICogWW91IGNhbiB1c2UgaXQgdG8gYWx0ZXIgaW5kaXZpZHVhbCBgVGFibGVJdGVtYHMgYnV0IGlmIHlvdSBuZWVkIHRvIGNoYW5nZVxuXHQgKiB0YWJsZSBzdHJ1Y3R1cmUsIHVzZSBgYWRkUm93KClgIGFuZC9vciBgYWRkQ29sdW1uKClgXG5cdCAqL1xuXHRnZXQgZGF0YSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBzZWxlY3Rpb24gc3RhdGUgb2Ygcm93cyBpbiB0aGUgdGFibGUuXG5cdCAqL1xuXHRyb3dzU2VsZWN0ZWQ6IGJvb2xlYW5bXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBleHBhbmRlZCBzdGF0ZSBvZiByb3dzIGluIHRoZSB0YWJsZS5cblx0ICovXG5cdHJvd3NFeHBhbmRlZDogYm9vbGVhbltdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb250ZXh0IG9mIHRoZSByb3cuXG5cdCAqXG5cdCAqIEl0IGFmZmVjdHMgc3R5bGluZyBvZiB0aGUgcm93IHRvIHJlZmxlY3QgdGhlIGNvbnRleHQuXG5cdCAqXG5cdCAqIHN0cmluZyBjYW4gYmUgb25lIG9mIGBcInN1Y2Nlc3NcIiB8IFwid2FybmluZ1wiIHwgXCJpbmZvXCIgfCBcImVycm9yXCIgfCBcIlwiYCBhbmQgaXQnc1xuXHQgKiBlbXB0eSBvciB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHQgKi9cblx0cm93c0NvbnRleHQ6IHN0cmluZ1tdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGNsYXNzIG5hbWUocykgb2YgdGhlIHJvdy5cblx0ICpcblx0ICogSXQgYWZmZWN0cyBzdHlsaW5nIG9mIHRoZSByb3cgdG8gcmVmbGVjdCB0aGUgYXBwZW5kZWQgY2xhc3MgbmFtZShzKS5cblx0ICpcblx0ICogSXQncyBlbXB0eSBvciB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHQgKi9cblx0cm93c0NsYXNzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGVhZGVyIGNlbGxzIG9mIHRoZSB0YWJsZS5cblx0ICovXG5cdGhlYWRlcjogVGFibGVIZWFkZXJJdGVtW10gPSBbXTtcblxuXHQvKipcblx0ICogVHJhY2tzIHRoZSBjdXJyZW50IHBhZ2UuXG5cdCAqL1xuXHRjdXJyZW50UGFnZSA9IDE7XG5cblx0LyoqXG5cdCAqIExlbmd0aCBvZiBwYWdlLlxuXHQgKi9cblx0cGFnZUxlbmd0aCA9IDEwO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0byBsb2FkIGluIHRoZSB0YWJsZVxuXHQgKi9cblx0aXNFbmQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU2V0IHRvIHRydWUgd2hlbiBsYXp5IGxvYWRpbmcgdG8gc2hvdyBsb2FkaW5nIGluZGljYXRvclxuXHQgKi9cblx0aXNMb2FkaW5nID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEFic29sdXRlIHRvdGFsIG51bWJlciBvZiByb3dzIG9mIHRoZSB0YWJsZS5cblx0ICovXG5cdHByb3RlY3RlZCBfdG90YWxEYXRhTGVuZ3RoOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIE1hbnVhbGx5IHNldCBkYXRhIGxlbmd0aCBpbiBjYXNlIHRoZSBkYXRhIGluIHRoZSB0YWJsZSBkb2Vzbid0XG5cdCAqIGNvcnJlY3RseSByZWZsZWN0IGFsbCB0aGUgZGF0YSB0aGF0IHRhYmxlIGlzIHRvIGRpc3BsYXkuXG5cdCAqXG5cdCAqIEV4YW1wbGU6IGlmIHlvdSBoYXZlIG11bHRpcGxlIHBhZ2VzIG9mIGRhdGEgdGhhdCB0YWJsZSB3aWxsIGRpc3BsYXlcblx0ICogYnV0IHlvdSdyZSBsb2FkaW5nIG9uZSBhdCBhIHRpbWUuXG5cdCAqXG5cdCAqIFNldCB0byBgbnVsbGAgdG8gcmVzZXQgdG8gZGVmYXVsdCBiZWhhdmlvci5cblx0ICovXG5cdHNldCB0b3RhbERhdGFMZW5ndGgobGVuZ3RoOiBudW1iZXIpIHtcblx0XHQvLyBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRob3V0IGEgcGFyYW1ldGVyIHdlIG5lZWQgdG8gc2V0IHRvIG51bGwgdG8gYXZvaWQgaGF2aW5nIHVuZGVmaW5lZCAhPSBudWxsXG5cdFx0dGhpcy5fdG90YWxEYXRhTGVuZ3RoID0gaXNOYU4obGVuZ3RoKSA/IG51bGwgOiBsZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogVG90YWwgbGVuZ3RoIG9mIGRhdGEgdGhhdCB0YWJsZSBoYXMgYWNjZXNzIHRvLCBvciB0aGUgYW1vdW50IG1hbnVhbGx5IHNldFxuXHQgKi9cblx0Z2V0IHRvdGFsRGF0YUxlbmd0aCgpIHtcblx0XHQvLyBpZiBtYW51YWxseSBzZXQgZGF0YSBsZW5ndGhcblx0XHRpZiAodGhpcy5fdG90YWxEYXRhTGVuZ3RoICE9PSBudWxsICYmIHRoaXMuX3RvdGFsRGF0YUxlbmd0aCA+PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEYXRhTGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIGlmIGVtcHR5IGRhdGFzZXRcblx0XHRpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5kYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCBpbiBgZGF0YWBcblx0ICovXG5cdHByb3RlY3RlZCBfZGF0YTogVGFibGVJdGVtW11bXSA9IFtbXV07XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgbW9kZWxzIGluc3RhbnRpYXRlZCwgdGhpcyBpcyB0byBtYWtlIHN1cmUgZWFjaCB0YWJsZSBoYXMgYSBkaWZmZXJlbnRcblx0ICogbW9kZWwgY291bnQgZm9yIHVuaXF1ZSBpZCBnZW5lcmF0aW9uLlxuXHQgKi9cblx0cHJvdGVjdGVkIHRhYmxlTW9kZWxDb3VudCA9IDA7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy50YWJsZU1vZGVsQ291bnQgPSBUYWJsZU1vZGVsLkNPVU5UKys7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBpZCBmb3IgdGhlIGdpdmVuIGNvbHVtblxuXHQgKlxuXHQgKiBAcGFyYW0gY29sdW1uIHRoZSBjb2x1bW4gdG8gZ2VuZXJhdGUgYW4gaWQgZm9yXG5cdCAqIEBwYXJhbSByb3cgdGhlIHJvdyBvZiB0aGUgaGVhZGVyIHRvIGdlbmVyYXRlIGFuIGlkIGZvclxuXHQgKi9cblx0Z2V0SWQoY29sdW1uOiBIZWFkZXJUeXBlLCByb3cgPSAwKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gYHRhYmxlLWhlYWRlci0ke3Jvd30tJHtjb2x1bW59LSR7dGhpcy50YWJsZU1vZGVsQ291bnR9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgaGVhZGVyLiBVc2VkIHRvIGxpbmsgdGhlIGNlbGxzIHdpdGggaGVhZGVycyAob3IgaGVhZGVycyB3aXRoIGhlYWRlcnMpXG5cdCAqXG5cdCAqIEBwYXJhbSBjb2x1bW4gdGhlIGNvbHVtbiB0byBzdGFydCBnZXR0aW5nIGhlYWRlcnMgZm9yXG5cdCAqIEBwYXJhbSBjb2xTcGFuIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBnZXQgaGVhZGVycyBmb3IgKGRlZmF1bHRzIHRvIDEpXG5cdCAqL1xuXHRnZXRIZWFkZXJJZChjb2x1bW46IEhlYWRlclR5cGUsIGNvbFNwYW4gPSAxKTogc3RyaW5nIHtcblx0XHRpZiAoY29sdW1uID09PSBcInNlbGVjdFwiIHx8IGNvbHVtbiA9PT0gXCJleHBhbmRcIikge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SWQoY29sdW1uKTtcblx0XHR9XG5cblx0XHRsZXQgaWRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IGNvbHVtbjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmICh0aGlzLmhlYWRlcltpXSkge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuXHRcdFx0XHRcdGlkcy5wdXNoKHRoaXMuZ2V0SWQoaSArIGopKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaWRzLmpvaW4oXCIgXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIGNsb3Nlc3QgaGVhZGVyIGJ5IHRyeWluZyB0aGUgYGNvbHVtbmAgYW5kIHRoZW4gd29ya2luZyBpdHMgd2F5IHRvIHRoZSBsZWZ0XG5cdCAqXG5cdCAqIEBwYXJhbSBjb2x1bW4gdGhlIHRhcmdldCBjb2x1bW5cblx0ICovXG5cdGdldEhlYWRlcihjb2x1bW46IG51bWJlcik6IFRhYmxlSGVhZGVySXRlbSB7XG5cdFx0aWYgKCF0aGlzLmhlYWRlcikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IGNvbHVtbjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGhlYWRlckNlbGwgPSB0aGlzLmhlYWRlcltpXTtcblx0XHRcdGlmIChoZWFkZXJDZWxsKSB7XG5cdFx0XHRcdHJldHVybiBoZWFkZXJDZWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaG93IG1hbnkgcm93cyBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcblx0ICovXG5cdHNlbGVjdGVkUm93c0NvdW50KCk6IG51bWJlciB7XG5cdFx0bGV0IGNvdW50ID0gMDtcblx0XHRpZiAodGhpcy5yb3dzU2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLmZvckVhY2gocm93U2VsZWN0ZWQgPT4ge1xuXHRcdFx0XHRpZiAocm93U2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaG93IG1hbnkgcm93cyBpcyBjdXJyZW50bHkgZXhwYW5kZWRcblx0ICovXG5cdGV4cGFuZGVkUm93c0NvdW50KCk6IG51bWJlciB7XG5cdFx0bGV0IGNvdW50ID0gMDtcblx0XHRpZiAodGhpcy5yb3dzRXhwYW5kZWQpIHtcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLmZvckVhY2gocm93RXhwYW5kZWQgPT4ge1xuXHRcdFx0XHRpZiAocm93RXhwYW5kZWQpIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYGluZGV4YHRoIHJvdyBvZiB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0cm93KGluZGV4OiBudW1iZXIpOiBUYWJsZUl0ZW1bXSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnJlYWxSb3dJbmRleChpbmRleCldO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSByb3cgdG8gdGhlIGBpbmRleGB0aCByb3cgb3IgYXBwZW5kcyB0byB0YWJsZSBpZiBpbmRleCBub3QgcHJvdmlkZWQuXG5cdCAqXG5cdCAqIElmIHJvdyBpcyBzaG9ydGVyIHRoYW4gb3RoZXIgcm93cyBvciBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgcGFkZGVkIHdpdGhcblx0ICogZW1wdHkgYFRhYmxlSXRlbWAgZWxlbWVudHMuXG5cdCAqXG5cdCAqIElmIHJvdyBpcyBsb25nZXIgdGhhbiBvdGhlciByb3dzLCBvdGhlcnMgd2lsbCBiZSBleHRlbmRlZCB0byBtYXRjaCBzbyBubyBkYXRhIGlzIGxvc3QuXG5cdCAqXG5cdCAqIElmIGNhbGxlZCBvbiBhbiBlbXB0eSB0YWJsZSB3aXRoIG5vIHBhcmFtZXRlcnMsIGl0IGNyZWF0ZXMgYSAxeDEgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBbcm93XVxuXHQgKiBAcGFyYW0gW2luZGV4XVxuXHQgKi9cblx0YWRkUm93KHJvdz86IFRhYmxlSXRlbVtdLCBpbmRleD86IG51bWJlcikge1xuXHRcdC8vIGlmIHRhYmxlIGVtcHR5IGNyZWF0ZSB0YWJsZSB3aXRoIHJvd1xuXHRcdGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPT09IDAgfHwgdGhpcy5kYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0bGV0IG5ld0RhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRcdG5ld0RhdGEucHVzaChyb3cgPyByb3cgOiBbbmV3IFRhYmxlSXRlbSgpXSk7ICAvLyByb3cgb3Igb25lIGVtcHR5IG9uZSBjb2x1bW4gcm93XG5cdFx0XHR0aGlzLmRhdGEgPSBuZXdEYXRhO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IHJlYWxSb3cgPSByb3c7XG5cdFx0Y29uc3QgY29sdW1uQ291bnQgPSB0aGlzLmRhdGFbMF0ubGVuZ3RoO1xuXG5cdFx0aWYgKHJvdyA9PSBudWxsKSB7XG5cdFx0XHRyZWFsUm93ID0gbmV3IEFycmF5PFRhYmxlSXRlbT4oKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuXHRcdFx0XHRyZWFsUm93LnB1c2gobmV3IFRhYmxlSXRlbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVhbFJvdy5sZW5ndGggPCBjb2x1bW5Db3VudCkge1xuXHRcdFx0Ly8gZXh0ZW5kIHRoZSBsZW5ndGggb2YgcmVhbFJvd1xuXHRcdFx0Y29uc3QgZGlmZmVyZW5jZSA9IGNvbHVtbkNvdW50IC0gcmVhbFJvdy5sZW5ndGg7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZlcmVuY2U7IGkrKykge1xuXHRcdFx0XHRyZWFsUm93LnB1c2gobmV3IFRhYmxlSXRlbSgpKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHJlYWxSb3cubGVuZ3RoID4gY29sdW1uQ291bnQpIHtcblx0XHRcdC8vIGV4dGVuZCB0aGUgbGVuZ3RoIG9mIGhlYWRlclxuXHRcdFx0bGV0IGRpZmZlcmVuY2UgPSByZWFsUm93Lmxlbmd0aCAtIHRoaXMuaGVhZGVyLmxlbmd0aDtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZGlmZmVyZW5jZTsgaisrKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdH1cblx0XHRcdC8vIGV4dGVuZCB0aGUgbGVuZ3RoIG9mIGV2ZXJ5IG90aGVyIHJvd1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bGV0IGN1cnJlbnRSb3cgPSB0aGlzLmRhdGFbaV07XG5cdFx0XHRcdGRpZmZlcmVuY2UgPSByZWFsUm93Lmxlbmd0aCAtIGN1cnJlbnRSb3cubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGRpZmZlcmVuY2U7IGorKykge1xuXHRcdFx0XHRcdGN1cnJlbnRSb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGluZGV4ID09IG51bGwpIHtcblx0XHRcdHRoaXMuZGF0YS5wdXNoKHJlYWxSb3cpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c1NlbGVjdGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLnB1c2goZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0V4cGFuZGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLnB1c2goZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0NvbnRleHQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ29udGV4dC5wdXNoKHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ2xhc3MgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ2xhc3MucHVzaCh1bmRlZmluZWQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCByaSA9IHRoaXMucmVhbFJvd0luZGV4KGluZGV4KTtcblx0XHRcdHRoaXMuZGF0YS5zcGxpY2UocmksIDAsIHJlYWxSb3cpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c1NlbGVjdGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLnNwbGljZShyaSwgMCwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0V4cGFuZGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLnNwbGljZShyaSwgMCwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0NvbnRleHQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ29udGV4dC5zcGxpY2UocmksIDAsIHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ2xhc3MgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ2xhc3Muc3BsaWNlKHJpLCAwLCB1bmRlZmluZWQpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBgaW5kZXhgdGggcm93LlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGRlbGV0ZVJvdyhpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgcnJpID0gdGhpcy5yZWFsUm93SW5kZXgoaW5kZXgpO1xuXHRcdHRoaXMuZGF0YS5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NTZWxlY3RlZC5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NFeHBhbmRlZC5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NDb250ZXh0LnNwbGljZShycmksIDEpO1xuXHRcdHRoaXMucm93c0NsYXNzLnNwbGljZShycmksIDEpO1xuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdGhhc0V4cGFuZGFibGVSb3dzKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc29tZShkYXRhID0+IGRhdGEuc29tZShkID0+IGQgJiYgZC5leHBhbmRlZERhdGEpKTsgLy8gY2hlY2tpbmcgZm9yIHNvbWUgaW4gMkQgYXJyYXlcblx0fVxuXG5cdGlzUm93RXhwYW5kYWJsZShpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVtpbmRleF0uc29tZShkID0+IGQgJiYgZC5leHBhbmRlZERhdGEpO1xuXHR9XG5cblx0aXNSb3dFeHBhbmRlZChpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMucm93c0V4cGFuZGVkW2luZGV4XTtcblx0fVxuXG5cdGdldFJvd0NvbnRleHQoaW5kZXg6IG51bWJlcikge1xuXHRcdHJldHVybiB0aGlzLnJvd3NDb250ZXh0W2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBpbmRleGB0aCBjb2x1bW4gb2YgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGNvbHVtbihpbmRleDogbnVtYmVyKTogVGFibGVJdGVtW10ge1xuXHRcdGxldCBjb2x1bW4gPSBuZXcgQXJyYXk8VGFibGVJdGVtPigpO1xuXHRcdGNvbnN0IHJpID0gdGhpcy5yZWFsQ29sdW1uSW5kZXgoaW5kZXgpO1xuXHRcdGNvbnN0IHJjID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmM7IGkrKykge1xuXHRcdFx0Y29uc3Qgcm93ID0gdGhpcy5kYXRhW2ldO1xuXHRcdFx0Y29sdW1uLnB1c2gocm93W3JpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbHVtbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY29sdW1uIHRvIHRoZSBgaW5kZXhgdGggY29sdW1uIG9yIGFwcGVuZHMgdG8gdGFibGUgaWYgaW5kZXggbm90IHByb3ZpZGVkLlxuXHQgKlxuXHQgKiBJZiBjb2x1bW4gaXMgc2hvcnRlciB0aGFuIG90aGVyIGNvbHVtbnMgb3Igbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIHBhZGRlZCB3aXRoXG5cdCAqIGVtcHR5IGBUYWJsZUl0ZW1gIGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBJZiBjb2x1bW4gaXMgbG9uZ2VyIHRoYW4gb3RoZXIgY29sdW1ucywgb3RoZXJzIHdpbGwgYmUgZXh0ZW5kZWQgdG8gbWF0Y2ggc28gbm8gZGF0YSBpcyBsb3N0LlxuXHQgKlxuXHQgKiBJZiBjYWxsZWQgb24gYW4gZW1wdHkgdGFibGUgd2l0aCBubyBwYXJhbWV0ZXJzLCBpdCBjcmVhdGVzIGEgMXgxIHRhYmxlLlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gW2NvbHVtbl1cblx0ICogQHBhcmFtIFtpbmRleF1cblx0ICovXG5cdGFkZENvbHVtbihjb2x1bW4/OiBUYWJsZUl0ZW1bXSwgaW5kZXg/OiBudW1iZXIpIHtcblx0XHQvLyBpZiB0YWJsZSBlbXB0eSBjcmVhdGUgdGFibGUgd2l0aCByb3dcblx0XHRpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoID09PSAwIHx8IHRoaXMuZGF0YVswXS5sZW5ndGggPT09IDApIHtcblx0XHRcdGxldCBuZXdEYXRhID0gbmV3IEFycmF5PEFycmF5PFRhYmxlSXRlbT4+KCk7XG5cdFx0XHRpZiAoY29sdW1uID09IG51bGwpIHtcblx0XHRcdFx0bmV3RGF0YS5wdXNoKFtuZXcgVGFibGVJdGVtKCldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IGl0ZW0gPSBjb2x1bW5baV07XG5cdFx0XHRcdFx0bmV3RGF0YS5wdXNoKFtpdGVtXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZGF0YSA9IG5ld0RhdGE7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgcmMgPSB0aGlzLmRhdGEubGVuZ3RoOyAgLy8gcm93IGNvdW50XG5cdFx0bGV0IGNpID0gdGhpcy5yZWFsQ29sdW1uSW5kZXgoaW5kZXgpO1xuXG5cdFx0Ly8gYXBwZW5kIG1pc3Npbmcgcm93c1xuXHRcdGZvciAobGV0IGkgPSAwOyBjb2x1bW4gIT0gbnVsbCAmJiBpIDwgY29sdW1uLmxlbmd0aCAtIHJjOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkUm93KCk7XG5cdFx0fVxuXHRcdHJjID0gdGhpcy5kYXRhLmxlbmd0aDtcblx0XHRpZiAoaW5kZXggPT0gbnVsbCkge1xuXHRcdFx0Ly8gYXBwZW5kIHRvIGVuZFxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYzsgaSsrKSB7XG5cdFx0XHRcdGxldCByb3cgPSB0aGlzLmRhdGFbaV07XG5cdFx0XHRcdHJvdy5wdXNoKGNvbHVtbiA9PSBudWxsIHx8IGNvbHVtbltpXSA9PSBudWxsID8gbmV3IFRhYmxlSXRlbSgpIDogY29sdW1uW2ldKTtcblx0XHRcdH1cblx0XHRcdC8vIHVwZGF0ZSBoZWFkZXIgaWYgbm90IGFscmVhZHkgc2V0IGJ5IHVzZXJcblx0XHRcdGlmICh0aGlzLmhlYWRlci5sZW5ndGggPCB0aGlzLmRhdGFbMF0ubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGluZGV4ID49IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gaWYgdHJ5aW5nIHRvIGFwcGVuZFxuXHRcdFx0XHRjaSsrO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW5zZXJ0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJjOyBpKyspIHtcblx0XHRcdFx0bGV0IHJvdyA9IHRoaXMuZGF0YVtpXTtcblx0XHRcdFx0cm93LnNwbGljZShjaSwgMCwgY29sdW1uID09IG51bGwgfHwgY29sdW1uW2ldID09IG51bGwgPyBuZXcgVGFibGVJdGVtKCkgOiBjb2x1bW5baV0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGhlYWRlciBpZiBub3QgYWxyZWFkeSBzZXQgYnkgdXNlclxuXHRcdFx0aWYgKHRoaXMuaGVhZGVyLmxlbmd0aCA8IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5oZWFkZXIuc3BsaWNlKGNpLCAwLCBuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBgaW5kZXhgdGggY29sdW1uLlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGRlbGV0ZUNvbHVtbihpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgcmNpID0gdGhpcy5yZWFsQ29sdW1uSW5kZXgoaW5kZXgpO1xuXHRcdGNvbnN0IHJvd0NvdW50ID0gdGhpcy5kYXRhLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcblx0XHRcdHRoaXMuZGF0YVtpXS5zcGxpY2UocmNpLCAxKTtcblx0XHR9XG5cdFx0Ly8gdXBkYXRlIGhlYWRlciBpZiBub3QgYWxyZWFkeSBzZXQgYnkgdXNlclxuXHRcdGlmICh0aGlzLmhlYWRlci5sZW5ndGggPiB0aGlzLmRhdGFbMF0ubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmhlYWRlci5zcGxpY2UocmNpLCAxKTtcblx0XHR9XG5cblx0XHR0aGlzLmRhdGFDaGFuZ2UuZW1pdCgpO1xuXHR9XG5cblx0bW92ZUNvbHVtbihpbmRleEZyb206IG51bWJlciwgaW5kZXhUbzogbnVtYmVyKSB7XG5cdFx0Y29uc3QgaGVhZGVyRnJvbSA9IHRoaXMuaGVhZGVyW2luZGV4RnJvbV07XG5cblx0XHR0aGlzLmFkZENvbHVtbih0aGlzLmNvbHVtbihpbmRleEZyb20pLCBpbmRleFRvKTtcblx0XHR0aGlzLmRlbGV0ZUNvbHVtbihpbmRleEZyb20gKyAoaW5kZXhUbyA8IGluZGV4RnJvbSA/IDEgOiAwKSk7XG5cblx0XHR0aGlzLmhlYWRlcltpbmRleFRvICsgKGluZGV4VG8gPiBpbmRleEZyb20gPyAtMSA6IDApXSA9IGhlYWRlckZyb207XG5cdH1cblxuXHQvKipcblx0ICogU29ydHMgdGhlIGRhdGEgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIG1vZGVsIGJhc2VkIG9uIGBjb21wYXJlKClgXG5cdCAqXG5cdCAqIERpcmVjdGlvbiBpcyBzZXQgYnkgYGFzY2VuZGluZ2AgYW5kIGBkZXNjZW5kaW5nYCBwcm9wZXJ0aWVzIG9mIGBUYWJsZUhlYWRlckl0ZW1gXG5cdCAqIGluIGBpbmRleGB0aCBjb2x1bW4uXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgY29sdW1uIGJhc2VkIG9uIHdoaWNoIGl0J3Mgc29ydGluZ1xuXHQgKi9cblx0c29ydChpbmRleDogbnVtYmVyKSB7XG5cdFx0dGhpcy5wdXNoUm93U3RhdGVUb01vZGVsRGF0YSgpO1xuXHRcdHRoaXMuZGF0YS5zb3J0KChhLCBiKSA9PiAodGhpcy5oZWFkZXJbaW5kZXhdLmRlc2NlbmRpbmcgPyAtMSA6IDEpICogdGhpcy5oZWFkZXJbaW5kZXhdLmNvbXBhcmUoYVtpbmRleF0sIGJbaW5kZXhdKSk7XG5cdFx0dGhpcy5wb3BSb3dTdGF0ZUZyb21Nb2RlbERhdGEoKTtcblx0XHR0aGlzLmhlYWRlci5mb3JFYWNoKGNvbHVtbiA9PiBjb2x1bW4uc29ydGVkID0gZmFsc2UpO1xuXHRcdHRoaXMuaGVhZGVyW2luZGV4XS5zb3J0ZWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYHJvd3NTZWxlY3RlZGAgYW5kIGByb3dzRXhwYW5kZWRgIGluZm8gdG8gbW9kZWwgZGF0YS5cblx0ICpcblx0ICogV2hlbiBzb3J0aW5nIHJvd3MsIGRvIHRoaXMgZmlyc3Qgc28gaW5mb3JtYXRpb24gYWJvdXQgcm93IHNlbGVjdGlvblxuXHQgKiBnZXRzIHNvcnRlZCB3aXRoIHRoZSBvdGhlciByb3cgaW5mby5cblx0ICpcblx0ICogQ2FsbCBgcG9wUm93U2VsZWN0aW9uRnJvbU1vZGVsRGF0YSgpYCBhZnRlciBzb3J0aW5nIHRvIG1ha2UgZXZlcnl0aGluZ1xuXHQgKiByaWdodCB3aXRoIHRoZSB3b3JsZCBhZ2Fpbi5cblx0ICovXG5cdHB1c2hSb3dTdGF0ZVRvTW9kZWxEYXRhKCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCByb3dTZWxlY3RlZE1hcmsgPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dTZWxlY3RlZE1hcmsuZGF0YSA9IHRoaXMucm93c1NlbGVjdGVkW2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93U2VsZWN0ZWRNYXJrKTtcblxuXHRcdFx0Y29uc3Qgcm93RXhwYW5kZWRNYXJrID0gbmV3IFRhYmxlSXRlbSgpO1xuXHRcdFx0cm93RXhwYW5kZWRNYXJrLmRhdGEgPSB0aGlzLnJvd3NFeHBhbmRlZFtpXTtcblx0XHRcdHRoaXMuZGF0YVtpXS5wdXNoKHJvd0V4cGFuZGVkTWFyayk7XG5cblx0XHRcdGNvbnN0IHJvd0NvbnRleHQgPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dDb250ZXh0LmRhdGEgPSB0aGlzLnJvd3NDb250ZXh0W2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93Q29udGV4dCk7XG5cblx0XHRcdGNvbnN0IHJvd0NsYXNzID0gbmV3IFRhYmxlSXRlbSgpO1xuXHRcdFx0cm93Q2xhc3MuZGF0YSA9IHRoaXMucm93c0NsYXNzW2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93Q2xhc3MpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXN0b3JlcyBgcm93c1NlbGVjdGVkYCBmcm9tIGRhdGEgcHVzaGVkIGJ5IGBwdXNoUm93U2VsZWN0aW9uVG9Nb2RlbERhdGEoKWBcblx0ICpcblx0ICogQ2FsbCBhZnRlciBzb3J0aW5nIGRhdGEgKGlmIHlvdSBwcmV2aW91c2x5IHB1c2hlZCB0byBtYWludGFpbiBzZWxlY3Rpb24gb3JkZXIpXG5cdCAqIHRvIG1ha2UgZXZlcnl0aGluZyByaWdodCB3aXRoIHRoZSB3b3JsZCBhZ2Fpbi5cblx0ICovXG5cdHBvcFJvd1N0YXRlRnJvbU1vZGVsRGF0YSgpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5yb3dzQ2xhc3NbaV0gPSB0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c0NvbnRleHRbaV0gPSB0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkW2ldID0gISF0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkW2ldID0gISF0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHJvdyBpcyBmaWx0ZXJlZCBvdXQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgZmlsdGVycyBpbiBoZWFkZXIgZmlsdGVycyBvdXQgdGhlIGBpbmRleGB0aCByb3dcblx0ICovXG5cdGlzUm93RmlsdGVyZWQoaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdGNvbnN0IHJlYWxJbmRleCA9IHRoaXMucmVhbFJvd0luZGV4KGluZGV4KTtcblx0XHRyZXR1cm4gdGhpcy5oZWFkZXIuc29tZSgoaXRlbSwgaSkgPT4gaXRlbSAmJiBpdGVtLmZpbHRlcih0aGlzLnJvdyhyZWFsSW5kZXgpW2ldKSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0L2Rlc2VsZWN0IGBpbmRleGB0aCByb3cgYmFzZWQgb24gdmFsdWVcblx0ICpcblx0ICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSByb3cgdG8gc2VsZWN0XG5cdCAqIEBwYXJhbSB2YWx1ZSBzdGF0ZSB0byBzZXQgdGhlIHJvdyB0by4gRGVmYXVsdHMgdG8gYHRydWVgXG5cdCAqL1xuXHRzZWxlY3RSb3coaW5kZXg6IG51bWJlciwgdmFsdWUgPSB0cnVlKSB7XG5cdFx0aWYgKHRoaXMuaXNSb3dEaXNhYmxlZChpbmRleCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWRbaW5kZXhdID0gdmFsdWU7XG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWRDaGFuZ2UuZW1pdChpbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0cyBvciBkZXNlbGVjdHMgYWxsIHJvd3MgaW4gdGhlIG1vZGVsXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSBzdGF0ZSB0byBzZXQgYWxsIHJvd3MgdG8uIERlZmF1bHRzIHRvIGB0cnVlYFxuXHQgKi9cblx0c2VsZWN0QWxsKHZhbHVlID0gdHJ1ZSkge1xuXHRcdGlmICh0aGlzLmRhdGEubGVuZ3RoID49IDEgJiYgdGhpcy5kYXRhWzBdLmxlbmd0aCA+PSAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93c1NlbGVjdGVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0Um93KGksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5zZWxlY3RBbGxDaGFuZ2UubmV4dCh2YWx1ZSk7XG5cdH1cblxuXHRpc1Jvd1NlbGVjdGVkKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5yb3dzU2VsZWN0ZWRbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiByb3cgaXMgZGlzYWJsZWQgb3Igbm90LlxuXHQgKi9cblx0aXNSb3dEaXNhYmxlZChpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3Qgcm93ID0gdGhpcy5kYXRhW2luZGV4XSBhcyBUYWJsZVJvdztcblx0XHRyZXR1cm4gISFyb3cuZGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kcy9Db2xsYXBzZXMgYGluZGV4YHRoIHJvdyBiYXNlZCBvbiB2YWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXggaW5kZXggb2YgdGhlIHJvdyB0byBleHBhbmQgb3IgY29sbGFwc2Vcblx0ICogQHBhcmFtIHZhbHVlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSByb3cuIGB0cnVlYCBpcyBleHBhbmRlZCBhbmQgYGZhbHNlYCBpcyBjb2xsYXBzZWRcblx0ICovXG5cdGV4cGFuZFJvdyhpbmRleDogbnVtYmVyLCB2YWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLnJvd3NFeHBhbmRlZFtpbmRleF0gPSB2YWx1ZTtcblx0XHR0aGlzLnJvd3NFeHBhbmRlZENoYW5nZS5lbWl0KGluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0cnVlIGluZGV4IG9mIGEgcm93IGJhc2VkIG9uIGl0J3MgcmVsYXRpdmUgcG9zaXRpb24uXG5cdCAqIExpa2UgaW4gUHl0aG9uLCBwb3NpdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmRcblx0ICogbmVnYXRpdmUgbnVtYmVycyBzdGFydCBmcm9tIHRoZSBib3R0b20uXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0cHJvdGVjdGVkIHJlYWxSb3dJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsSW5kZXgoaW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRydWUgaW5kZXggb2YgYSBjb2x1bW4gYmFzZWQgb24gaXQncyByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogTGlrZSBpbiBQeXRob24sIHBvc2l0aXZlIG51bWJlcnMgc3RhcnQgZnJvbSB0aGUgdG9wIGFuZFxuXHQgKiBuZWdhdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIGJvdHRvbS5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqL1xuXHRwcm90ZWN0ZWQgcmVhbENvbHVtbkluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnJlYWxJbmRleChpbmRleCwgdGhpcy5kYXRhWzBdLmxlbmd0aCk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJpYyBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIHJlYWwgaW5kZXggb2Ygc29tZXRoaW5nLlxuXHQgKiBVc2VkIGJ5IGByZWFsUm93SW5kZXgoKWAgYW5kIGByZWFsQ29sdW1uSW5kZXgoKWBcblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBsZW5ndGhcblx0ICovXG5cdHByb3RlY3RlZCByZWFsSW5kZXgoaW5kZXg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGlmIChpbmRleCA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKGluZGV4ID49IDApIHtcblx0XHRcdHJldHVybiBpbmRleCA+PSBsZW5ndGggPyBsZW5ndGggLSAxIDogaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAtaW5kZXggPj0gbGVuZ3RoID8gMCA6IGxlbmd0aCArIGluZGV4O1xuXHRcdH1cblx0fVxufVxuIl19