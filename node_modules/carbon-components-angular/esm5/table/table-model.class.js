/**
 *
 * carbon-angular v0.0.0 | table-model.class.js
 *
 * Copyright 2014, 2022 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { EventEmitter } from "@angular/core";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { Subject } from "rxjs";
/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
var TableModel = /** @class */ (function () {
    function TableModel() {
        this.dataChange = new EventEmitter();
        this.rowsSelectedChange = new EventEmitter();
        this.rowsExpandedChange = new EventEmitter();
        /**
         * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
         * all rows are selected.
         */
        this.selectAllChange = new Subject();
        /**
         * Contains information about selection state of rows in the table.
         */
        this.rowsSelected = [];
        /**
         * Contains information about expanded state of rows in the table.
         */
        this.rowsExpanded = [];
        /**
         * Contains information about the context of the row.
         *
         * It affects styling of the row to reflect the context.
         *
         * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
         * empty or undefined by default
         */
        this.rowsContext = [];
        /**
         * Contains class name(s) of the row.
         *
         * It affects styling of the row to reflect the appended class name(s).
         *
         * It's empty or undefined by default
         */
        this.rowsClass = [];
        /**
         * Contains information about the header cells of the table.
         */
        this.header = [];
        /**
         * Tracks the current page.
         */
        this.currentPage = 1;
        /**
         * Length of page.
         */
        this.pageLength = 10;
        /**
         * Set to true when there is no more data to load in the table
         */
        this.isEnd = false;
        /**
         * Set to true when lazy loading to show loading indicator
         */
        this.isLoading = false;
        /**
         * Used in `data`
         */
        this._data = [[]];
        /**
         * The number of models instantiated, this is to make sure each table has a different
         * model count for unique id generation.
         */
        this.tableModelCount = 0;
        this.tableModelCount = TableModel.COUNT++;
    }
    Object.defineProperty(TableModel.prototype, "data", {
        /**
         * Gets the full data.
         *
         * You can use it to alter individual `TableItem`s but if you need to change
         * table structure, use `addRow()` and/or `addColumn()`
         */
        get: function () {
            return this._data;
        },
        /**
         * Sets data of the table.
         *
         * Make sure all rows are the same length to keep the column count accurate.
         */
        set: function (newData) {
            if (!newData || (Array.isArray(newData) && newData.length === 0)) {
                newData = [[]];
            }
            this._data = newData;
            // init rowsSelected
            this.rowsSelected = new Array(this._data.length).fill(false);
            this.rowsExpanded = new Array(this._data.length).fill(false);
            // init rowsContext
            this.rowsContext = new Array(this._data.length);
            // init rowsClass
            this.rowsClass = new Array(this._data.length);
            // only create a fresh header if necessary (header doesn't exist or differs in length)
            if (this.header == null || (this.header.length !== this._data[0].length && this._data[0].length > 0)) {
                var header = new Array();
                for (var i = 0; i < this._data[0].length; i++) {
                    header.push(new TableHeaderItem());
                }
                this.header = header;
            }
            this.dataChange.emit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableModel.prototype, "totalDataLength", {
        /**
         * Total length of data that table has access to, or the amount manually set
         */
        get: function () {
            // if manually set data length
            if (this._totalDataLength !== null && this._totalDataLength >= 0) {
                return this._totalDataLength;
            }
            // if empty dataset
            if (this.data && this.data.length === 1 && this.data[0].length === 0) {
                return 0;
            }
            return this.data.length;
        },
        /**
         * Manually set data length in case the data in the table doesn't
         * correctly reflect all the data that table is to display.
         *
         * Example: if you have multiple pages of data that table will display
         * but you're loading one at a time.
         *
         * Set to `null` to reset to default behavior.
         */
        set: function (length) {
            // if this function is called without a parameter we need to set to null to avoid having undefined != null
            this._totalDataLength = isNaN(length) ? null : length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    TableModel.prototype.getId = function (column, row) {
        if (row === void 0) { row = 0; }
        return "table-header-" + row + "-" + column + "-" + this.tableModelCount;
    };
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    TableModel.prototype.getHeaderId = function (column, colSpan) {
        if (colSpan === void 0) { colSpan = 1; }
        if (column === "select" || column === "expand") {
            return this.getId(column);
        }
        var ids = [];
        for (var i = column; i >= 0; i--) {
            if (this.header[i]) {
                for (var j = 0; j < colSpan; j++) {
                    ids.push(this.getId(i + j));
                }
                break;
            }
        }
        return ids.join(" ");
    };
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    TableModel.prototype.getHeader = function (column) {
        if (!this.header) {
            return null;
        }
        for (var i = column; i >= 0; i--) {
            var headerCell = this.header[i];
            if (headerCell) {
                return headerCell;
            }
        }
        return null;
    };
    /**
     * Returns how many rows is currently selected
     */
    TableModel.prototype.selectedRowsCount = function () {
        var count = 0;
        if (this.rowsSelected) {
            this.rowsSelected.forEach(function (rowSelected) {
                if (rowSelected) {
                    count++;
                }
            });
        }
        return count;
    };
    /**
     * Returns how many rows is currently expanded
     */
    TableModel.prototype.expandedRowsCount = function () {
        var count = 0;
        if (this.rowsExpanded) {
            this.rowsExpanded.forEach(function (rowExpanded) {
                if (rowExpanded) {
                    count++;
                }
            });
        }
        return count;
    };
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.row = function (index) {
        return this.data[this.realRowIndex(index)];
    };
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    TableModel.prototype.addRow = function (row, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            var newData = new Array();
            newData.push(row ? row : [new TableItem()]); // row or one empty one column row
            this.data = newData;
            return;
        }
        var realRow = row;
        var columnCount = this.data[0].length;
        if (row == null) {
            realRow = new Array();
            for (var i = 0; i < columnCount; i++) {
                realRow.push(new TableItem());
            }
        }
        if (realRow.length < columnCount) {
            // extend the length of realRow
            var difference = columnCount - realRow.length;
            for (var i = 0; i < difference; i++) {
                realRow.push(new TableItem());
            }
        }
        else if (realRow.length > columnCount) {
            // extend the length of header
            var difference = realRow.length - this.header.length;
            for (var j = 0; j < difference; j++) {
                this.header.push(new TableHeaderItem());
            }
            // extend the length of every other row
            for (var i = 0; i < this.data.length; i++) {
                var currentRow = this.data[i];
                difference = realRow.length - currentRow.length;
                for (var j = 0; j < difference; j++) {
                    currentRow.push(new TableItem());
                }
            }
        }
        if (index == null) {
            this.data.push(realRow);
            // update rowsSelected property for length
            this.rowsSelected.push(false);
            // update rowsExpanded property for length
            this.rowsExpanded.push(false);
            // update rowsContext property for length
            this.rowsContext.push(undefined);
            // update rowsClass property for length
            this.rowsClass.push(undefined);
        }
        else {
            var ri = this.realRowIndex(index);
            this.data.splice(ri, 0, realRow);
            // update rowsSelected property for length
            this.rowsSelected.splice(ri, 0, false);
            // update rowsExpanded property for length
            this.rowsExpanded.splice(ri, 0, false);
            // update rowsContext property for length
            this.rowsContext.splice(ri, 0, undefined);
            // update rowsClass property for length
            this.rowsClass.splice(ri, 0, undefined);
        }
        this.dataChange.emit();
    };
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.deleteRow = function (index) {
        var rri = this.realRowIndex(index);
        this.data.splice(rri, 1);
        this.rowsSelected.splice(rri, 1);
        this.rowsExpanded.splice(rri, 1);
        this.rowsContext.splice(rri, 1);
        this.rowsClass.splice(rri, 1);
        this.dataChange.emit();
    };
    TableModel.prototype.hasExpandableRows = function () {
        return this.data.some(function (data) { return data.some(function (d) { return d && d.expandedData; }); }); // checking for some in 2D array
    };
    TableModel.prototype.isRowExpandable = function (index) {
        return this.data[index].some(function (d) { return d && d.expandedData; });
    };
    TableModel.prototype.isRowExpanded = function (index) {
        return this.rowsExpanded[index];
    };
    TableModel.prototype.getRowContext = function (index) {
        return this.rowsContext[index];
    };
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.column = function (index) {
        var column = new Array();
        var ri = this.realColumnIndex(index);
        var rc = this.data.length;
        for (var i = 0; i < rc; i++) {
            var row = this.data[i];
            column.push(row[ri]);
        }
        return column;
    };
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    TableModel.prototype.addColumn = function (column, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            var newData = new Array();
            if (column == null) {
                newData.push([new TableItem()]);
            }
            else {
                for (var i = 0; i < column.length; i++) {
                    var item = column[i];
                    newData.push([item]);
                }
            }
            this.data = newData;
            return;
        }
        var rc = this.data.length; // row count
        var ci = this.realColumnIndex(index);
        // append missing rows
        for (var i = 0; column != null && i < column.length - rc; i++) {
            this.addRow();
        }
        rc = this.data.length;
        if (index == null) {
            // append to end
            for (var i = 0; i < rc; i++) {
                var row = this.data[i];
                row.push(column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.push(new TableHeaderItem());
            }
        }
        else {
            if (index >= this.data[0].length) {
                // if trying to append
                ci++;
            }
            // insert
            for (var i = 0; i < rc; i++) {
                var row = this.data[i];
                row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.splice(ci, 0, new TableHeaderItem());
            }
        }
        this.dataChange.emit();
    };
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    TableModel.prototype.deleteColumn = function (index) {
        var rci = this.realColumnIndex(index);
        var rowCount = this.data.length;
        for (var i = 0; i < rowCount; i++) {
            this.data[i].splice(rci, 1);
        }
        // update header if not already set by user
        if (this.header.length > this.data[0].length) {
            this.header.splice(rci, 1);
        }
        this.dataChange.emit();
    };
    TableModel.prototype.moveColumn = function (indexFrom, indexTo) {
        var headerFrom = this.header[indexFrom];
        this.addColumn(this.column(indexFrom), indexTo);
        this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
        this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
    };
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    TableModel.prototype.sort = function (index) {
        var _this = this;
        this.pushRowStateToModelData();
        this.data.sort(function (a, b) { return (_this.header[index].descending ? -1 : 1) * _this.header[index].compare(a[index], b[index]); });
        this.popRowStateFromModelData();
        this.header.forEach(function (column) { return column.sorted = false; });
        this.header[index].sorted = true;
    };
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    TableModel.prototype.pushRowStateToModelData = function () {
        for (var i = 0; i < this.data.length; i++) {
            var rowSelectedMark = new TableItem();
            rowSelectedMark.data = this.rowsSelected[i];
            this.data[i].push(rowSelectedMark);
            var rowExpandedMark = new TableItem();
            rowExpandedMark.data = this.rowsExpanded[i];
            this.data[i].push(rowExpandedMark);
            var rowContext = new TableItem();
            rowContext.data = this.rowsContext[i];
            this.data[i].push(rowContext);
            var rowClass = new TableItem();
            rowClass.data = this.rowsClass[i];
            this.data[i].push(rowClass);
        }
    };
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    TableModel.prototype.popRowStateFromModelData = function () {
        for (var i = 0; i < this.data.length; i++) {
            this.rowsClass[i] = this.data[i].pop().data;
            this.rowsContext[i] = this.data[i].pop().data;
            this.rowsExpanded[i] = !!this.data[i].pop().data;
            this.rowsSelected[i] = !!this.data[i].pop().data;
        }
    };
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    TableModel.prototype.isRowFiltered = function (index) {
        var _this = this;
        var realIndex = this.realRowIndex(index);
        return this.header.some(function (item, i) { return item && item.filter(_this.row(realIndex)[i]); });
    };
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    TableModel.prototype.selectRow = function (index, value) {
        if (value === void 0) { value = true; }
        if (this.isRowDisabled(index)) {
            return;
        }
        this.rowsSelected[index] = value;
        this.rowsSelectedChange.emit(index);
    };
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    TableModel.prototype.selectAll = function (value) {
        if (value === void 0) { value = true; }
        if (this.data.length >= 1 && this.data[0].length >= 1) {
            for (var i = 0; i < this.rowsSelected.length; i++) {
                this.selectRow(i, value);
            }
        }
        this.selectAllChange.next(value);
    };
    TableModel.prototype.isRowSelected = function (index) {
        return this.rowsSelected[index];
    };
    /**
     * Checks if row is disabled or not.
     */
    TableModel.prototype.isRowDisabled = function (index) {
        var row = this.data[index];
        return !!row.disabled;
    };
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    TableModel.prototype.expandRow = function (index, value) {
        if (value === void 0) { value = true; }
        this.rowsExpanded[index] = value;
        this.rowsExpandedChange.emit(index);
    };
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    TableModel.prototype.realRowIndex = function (index) {
        return this.realIndex(index, this.data.length);
    };
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    TableModel.prototype.realColumnIndex = function (index) {
        return this.realIndex(index, this.data[0].length);
    };
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    TableModel.prototype.realIndex = function (index, length) {
        if (index == null) {
            return length - 1;
        }
        else if (index >= 0) {
            return index >= length ? length - 1 : index;
        }
        else {
            return -index >= length ? 0 : length + index;
        }
    };
    /**
     * The number of models instantiated, used for (among other things) unique id generation
     */
    TableModel.COUNT = 0;
    return TableModel;
}());
export { TableModel };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtbW9kZWwuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsidGFibGUtbW9kZWwuY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFlBQVksRUFDWixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJL0I7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSDtJQWdLQztRQXhIQSxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNoQyx1QkFBa0IsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBQ2hELHVCQUFrQixHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFDaEQ7OztXQUdHO1FBQ0gsb0JBQWUsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO1FBWXpDOztXQUVHO1FBQ0gsaUJBQVksR0FBYyxFQUFFLENBQUM7UUFFN0I7O1dBRUc7UUFDSCxpQkFBWSxHQUFjLEVBQUUsQ0FBQztRQUU3Qjs7Ozs7OztXQU9HO1FBQ0gsZ0JBQVcsR0FBYSxFQUFFLENBQUM7UUFFM0I7Ozs7OztXQU1HO1FBQ0gsY0FBUyxHQUFhLEVBQUUsQ0FBQztRQUV6Qjs7V0FFRztRQUNILFdBQU0sR0FBc0IsRUFBRSxDQUFDO1FBRS9COztXQUVHO1FBQ0gsZ0JBQVcsR0FBRyxDQUFDLENBQUM7UUFFaEI7O1dBRUc7UUFDSCxlQUFVLEdBQUcsRUFBRSxDQUFDO1FBRWhCOztXQUVHO1FBQ0gsVUFBSyxHQUFHLEtBQUssQ0FBQztRQUVkOztXQUVHO1FBQ0gsY0FBUyxHQUFHLEtBQUssQ0FBQztRQXNDbEI7O1dBRUc7UUFDTyxVQUFLLEdBQWtCLENBQUMs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RyxLQUFLLENBQUM7UUFDakMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08saUNBQVksR0FBdEIsVUFBdUIsS0FBYTtRQUNuQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLG9DQUFlLEdBQXpCLFVBQTBCLEtBQWE7UUFDdEMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTyw4QkFBUyxHQUFuQixVQUFvQixLQUFhLEVBQUUsTUFBYztRQUNoRCxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7WUFDbEIsT0FBTyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2xCO2FBQU0sSUFBSSxLQUFLLElBQUksQ0FBQyxFQUFFO1lBQ3RCLE9BQU8sS0FBSyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1NBQzVDO2FBQU07WUFDTixPQUFPLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1NBQzdDO0lBQ0YsQ0FBQztJQXJwQkQ7O09BRUc7SUFDYyxnQkFBSyxHQUFHLENBQUMsQ0FBQztJQW1wQjVCLGlCQUFDO0NBQUEsQUF2cEJELElBdXBCQztTQXZwQlksVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEV2ZW50RW1pdHRlclxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5pbXBvcnQgeyBQYWdpbmF0aW9uTW9kZWwgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9wYWdpbmF0aW9uXCI7XG5pbXBvcnQgeyBUYWJsZUhlYWRlckl0ZW0gfSBmcm9tIFwiLi90YWJsZS1oZWFkZXItaXRlbS5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVJdGVtIH0gZnJvbSBcIi4vdGFibGUtaXRlbS5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVSb3cgfSBmcm9tIFwiLi90YWJsZS1yb3cuY2xhc3NcIjtcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tIFwicnhqc1wiO1xuXG5leHBvcnQgdHlwZSBIZWFkZXJUeXBlID0gbnVtYmVyIHwgXCJzZWxlY3RcIiB8IFwiZXhwYW5kXCI7XG5cbi8qKlxuICogVGFibGVNb2RlbCByZXByZXNlbnRzIGEgZGF0YSBtb2RlbCBmb3IgdHdvLWRpbWVuc2lvbmFsIGRhdGEuIEl0J3MgdXNlZCBmb3IgYWxsIHRoaW5ncyB0YWJsZVxuICogKHRhYmxlIGNvbXBvbmVudCwgdGFibGUgdG9vbGJhciwgcGFnaW5hdGlvbiwgZXRjKVxuICpcbiAqIFRhYmxlTW9kZWwgbWFuYWdlcyBpdHMgaW50ZXJuYWwgZGF0YSBpbnRlZ3JpdHkgdmVyeSB3ZWxsIGlmIHlvdSB1c2UgdGhlIHByb3ZpZGVkIGhlbHBlclxuICogZnVuY3Rpb25zIGZvciBtb2RpZnlpbmcgcm93cyBhbmQgY29sdW1ucyBhbmQgYXNzaWduaW5nIGhlYWRlciBhbmQgZGF0YSBpbiB0aGF0IG9yZGVyLlxuICpcbiAqIEl0IGFsc28gcHJvdmlkZXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgZGF0YSBzbyB5b3UgY2FuIHJlYWQgYW5kIG1vZGlmeSBpdC5cbiAqIElmIHlvdSBjaGFuZ2UgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZGF0YSAoYnkgZGlyZWN0bHkgcHVzaGluZyBpbnRvIHRoZSBhcnJheXMgb3Igb3RoZXJ3aXNlKSxcbiAqIGtlZXAgaW4gbWluZCB0byBrZWVwIHRoZSBkYXRhIHN0cnVjdHVyZSBpbnRhY3QuXG4gKlxuICogSGVhZGVyIGxlbmd0aCBhbmQgbGVuZ3RoIG9mIGV2ZXJ5IGxpbmUgaW4gdGhlIGRhdGEgc2hvdWxkIGJlIGVxdWFsLlxuICpcbiAqIElmIHRoZXkgYXJlIG5vdCBjb25zaXN0ZW50LCB1bmV4cGVjdGVkIHRoaW5ncyB3aWxsIGhhcHBlbi5cbiAqXG4gKiBVc2UgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyB3aGVuIGluIGRvdWJ0LlxuICovXG5leHBvcnQgY2xhc3MgVGFibGVNb2RlbCBpbXBsZW1lbnRzIFBhZ2luYXRpb25Nb2RlbCB7XG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIG1vZGVscyBpbnN0YW50aWF0ZWQsIHVzZWQgZm9yIChhbW9uZyBvdGhlciB0aGluZ3MpIHVuaXF1ZSBpZCBnZW5lcmF0aW9uXG5cdCAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljIENPVU5UID0gMDtcblxuXHQvKipcblx0ICogU2V0cyBkYXRhIG9mIHRoZSB0YWJsZS5cblx0ICpcblx0ICogTWFrZSBzdXJlIGFsbCByb3dzIGFyZSB0aGUgc2FtZSBsZW5ndGggdG8ga2VlcCB0aGUgY29sdW1uIGNvdW50IGFjY3VyYXRlLlxuXHQgKi9cblx0c2V0IGRhdGEobmV3RGF0YTogVGFibGVJdGVtW11bXSkge1xuXHRcdGlmICghbmV3RGF0YSB8fCAoQXJyYXkuaXNBcnJheShuZXdEYXRhKSAmJiBuZXdEYXRhLmxlbmd0aCA9PT0gMCkgKSB7XG5cdFx0XHRuZXdEYXRhID0gW1tdXTtcblx0XHR9XG5cblx0XHR0aGlzLl9kYXRhID0gbmV3RGF0YTtcblxuXHRcdC8vIGluaXQgcm93c1NlbGVjdGVkXG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWQgPSBuZXcgQXJyYXk8Ym9vbGVhbj4odGhpcy5fZGF0YS5sZW5ndGgpLmZpbGwoZmFsc2UpO1xuXHRcdHRoaXMucm93c0V4cGFuZGVkID0gbmV3IEFycmF5PGJvb2xlYW4+KHRoaXMuX2RhdGEubGVuZ3RoKS5maWxsKGZhbHNlKTtcblxuXHRcdC8vIGluaXQgcm93c0NvbnRleHRcblx0XHR0aGlzLnJvd3NDb250ZXh0ID0gbmV3IEFycmF5PHN0cmluZz4odGhpcy5fZGF0YS5sZW5ndGgpO1xuXG5cdFx0Ly8gaW5pdCByb3dzQ2xhc3Ncblx0XHR0aGlzLnJvd3NDbGFzcyA9IG5ldyBBcnJheTxzdHJpbmc+KHRoaXMuX2RhdGEubGVuZ3RoKTtcblxuXHRcdC8vIG9ubHkgY3JlYXRlIGEgZnJlc2ggaGVhZGVyIGlmIG5lY2Vzc2FyeSAoaGVhZGVyIGRvZXNuJ3QgZXhpc3Qgb3IgZGlmZmVycyBpbiBsZW5ndGgpXG5cdFx0aWYgKHRoaXMuaGVhZGVyID09IG51bGwgfHwgKHRoaXMuaGVhZGVyLmxlbmd0aCAhPT0gdGhpcy5fZGF0YVswXS5sZW5ndGggJiYgdGhpcy5fZGF0YVswXS5sZW5ndGggPiAwKSkge1xuXHRcdFx0bGV0IGhlYWRlciA9IG5ldyBBcnJheTxUYWJsZUhlYWRlckl0ZW0+KCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGFbMF0ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHRkYXRhQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRyb3dzU2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblx0cm93c0V4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cdC8qKlxuXHQgKiBHZXRzIGVtaXR0ZWQgd2hlbiBgc2VsZWN0QWxsYCBpcyBjYWxsZWQuIEVtaXRzIGZhbHNlIGlmIGFsbCByb3dzIGFyZSBkZXNlbGVjdGVkIGFuZCB0cnVlIGlmXG5cdCAqIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cblx0ICovXG5cdHNlbGVjdEFsbENoYW5nZSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZ1bGwgZGF0YS5cblx0ICpcblx0ICogWW91IGNhbiB1c2UgaXQgdG8gYWx0ZXIgaW5kaXZpZHVhbCBgVGFibGVJdGVtYHMgYnV0IGlmIHlvdSBuZWVkIHRvIGNoYW5nZVxuXHQgKiB0YWJsZSBzdHJ1Y3R1cmUsIHVzZSBgYWRkUm93KClgIGFuZC9vciBgYWRkQ29sdW1uKClgXG5cdCAqL1xuXHRnZXQgZGF0YSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBzZWxlY3Rpb24gc3RhdGUgb2Ygcm93cyBpbiB0aGUgdGFibGUuXG5cdCAqL1xuXHRyb3dzU2VsZWN0ZWQ6IGJvb2xlYW5bXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBleHBhbmRlZCBzdGF0ZSBvZiByb3dzIGluIHRoZSB0YWJsZS5cblx0ICovXG5cdHJvd3NFeHBhbmRlZDogYm9vbGVhbltdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb250ZXh0IG9mIHRoZSByb3cuXG5cdCAqXG5cdCAqIEl0IGFmZmVjdHMgc3R5bGluZyBvZiB0aGUgcm93IHRvIHJlZmxlY3QgdGhlIGNvbnRleHQuXG5cdCAqXG5cdCAqIHN0cmluZyBjYW4gYmUgb25lIG9mIGBcInN1Y2Nlc3NcIiB8IFwid2FybmluZ1wiIHwgXCJpbmZvXCIgfCBcImVycm9yXCIgfCBcIlwiYCBhbmQgaXQnc1xuXHQgKiBlbXB0eSBvciB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHQgKi9cblx0cm93c0NvbnRleHQ6IHN0cmluZ1tdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGNsYXNzIG5hbWUocykgb2YgdGhlIHJvdy5cblx0ICpcblx0ICogSXQgYWZmZWN0cyBzdHlsaW5nIG9mIHRoZSByb3cgdG8gcmVmbGVjdCB0aGUgYXBwZW5kZWQgY2xhc3MgbmFtZShzKS5cblx0ICpcblx0ICogSXQncyBlbXB0eSBvciB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHQgKi9cblx0cm93c0NsYXNzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGVhZGVyIGNlbGxzIG9mIHRoZSB0YWJsZS5cblx0ICovXG5cdGhlYWRlcjogVGFibGVIZWFkZXJJdGVtW10gPSBbXTtcblxuXHQvKipcblx0ICogVHJhY2tzIHRoZSBjdXJyZW50IHBhZ2UuXG5cdCAqL1xuXHRjdXJyZW50UGFnZSA9IDE7XG5cblx0LyoqXG5cdCAqIExlbmd0aCBvZiBwYWdlLlxuXHQgKi9cblx0cGFnZUxlbmd0aCA9IDEwO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0byBsb2FkIGluIHRoZSB0YWJsZVxuXHQgKi9cblx0aXNFbmQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU2V0IHRvIHRydWUgd2hlbiBsYXp5IGxvYWRpbmcgdG8gc2hvdyBsb2FkaW5nIGluZGljYXRvclxuXHQgKi9cblx0aXNMb2FkaW5nID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEFic29sdXRlIHRvdGFsIG51bWJlciBvZiByb3dzIG9mIHRoZSB0YWJsZS5cblx0ICovXG5cdHByb3RlY3RlZCBfdG90YWxEYXRhTGVuZ3RoOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIE1hbnVhbGx5IHNldCBkYXRhIGxlbmd0aCBpbiBjYXNlIHRoZSBkYXRhIGluIHRoZSB0YWJsZSBkb2Vzbid0XG5cdCAqIGNvcnJlY3RseSByZWZsZWN0IGFsbCB0aGUgZGF0YSB0aGF0IHRhYmxlIGlzIHRvIGRpc3BsYXkuXG5cdCAqXG5cdCAqIEV4YW1wbGU6IGlmIHlvdSBoYXZlIG11bHRpcGxlIHBhZ2VzIG9mIGRhdGEgdGhhdCB0YWJsZSB3aWxsIGRpc3BsYXlcblx0ICogYnV0IHlvdSdyZSBsb2FkaW5nIG9uZSBhdCBhIHRpbWUuXG5cdCAqXG5cdCAqIFNldCB0byBgbnVsbGAgdG8gcmVzZXQgdG8gZGVmYXVsdCBiZWhhdmlvci5cblx0ICovXG5cdHNldCB0b3RhbERhdGFMZW5ndGgobGVuZ3RoOiBudW1iZXIpIHtcblx0XHQvLyBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRob3V0IGEgcGFyYW1ldGVyIHdlIG5lZWQgdG8gc2V0IHRvIG51bGwgdG8gYXZvaWQgaGF2aW5nIHVuZGVmaW5lZCAhPSBudWxsXG5cdFx0dGhpcy5fdG90YWxEYXRhTGVuZ3RoID0gaXNOYU4obGVuZ3RoKSA/IG51bGwgOiBsZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogVG90YWwgbGVuZ3RoIG9mIGRhdGEgdGhhdCB0YWJsZSBoYXMgYWNjZXNzIHRvLCBvciB0aGUgYW1vdW50IG1hbnVhbGx5IHNldFxuXHQgKi9cblx0Z2V0IHRvdGFsRGF0YUxlbmd0aCgpIHtcblx0XHQvLyBpZiBtYW51YWxseSBzZXQgZGF0YSBsZW5ndGhcblx0XHRpZiAodGhpcy5fdG90YWxEYXRhTGVuZ3RoICE9PSBudWxsICYmIHRoaXMuX3RvdGFsRGF0YUxlbmd0aCA+PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEYXRhTGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIGlmIGVtcHR5IGRhdGFzZXRcblx0XHRpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5kYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCBpbiBgZGF0YWBcblx0ICovXG5cdHByb3RlY3RlZCBfZGF0YTogVGFibGVJdGVtW11bXSA9IFtbXV07XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgbW9kZWxzIGluc3RhbnRpYXRlZCwgdGhpcyBpcyB0byBtYWtlIHN1cmUgZWFjaCB0YWJsZSBoYXMgYSBkaWZmZXJlbnRcblx0ICogbW9kZWwgY291bnQgZm9yIHVuaXF1ZSBpZCBnZW5lcmF0aW9uLlxuXHQgKi9cblx0cHJvdGVjdGVkIHRhYmxlTW9kZWxDb3VudCA9IDA7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy50YWJsZU1vZGVsQ291bnQgPSBUYWJsZU1vZGVsLkNPVU5UKys7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBpZCBmb3IgdGhlIGdpdmVuIGNvbHVtblxuXHQgKlxuXHQgKiBAcGFyYW0gY29sdW1uIHRoZSBjb2x1bW4gdG8gZ2VuZXJhdGUgYW4gaWQgZm9yXG5cdCAqIEBwYXJhbSByb3cgdGhlIHJvdyBvZiB0aGUgaGVhZGVyIHRvIGdlbmVyYXRlIGFuIGlkIGZvclxuXHQgKi9cblx0Z2V0SWQoY29sdW1uOiBIZWFkZXJUeXBlLCByb3cgPSAwKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gYHRhYmxlLWhlYWRlci0ke3Jvd30tJHtjb2x1bW59LSR7dGhpcy50YWJsZU1vZGVsQ291bnR9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgaGVhZGVyLiBVc2VkIHRvIGxpbmsgdGhlIGNlbGxzIHdpdGggaGVhZGVycyAob3IgaGVhZGVycyB3aXRoIGhlYWRlcnMpXG5cdCAqXG5cdCAqIEBwYXJhbSBjb2x1bW4gdGhlIGNvbHVtbiB0byBzdGFydCBnZXR0aW5nIGhlYWRlcnMgZm9yXG5cdCAqIEBwYXJhbSBjb2xTcGFuIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBnZXQgaGVhZGVycyBmb3IgKGRlZmF1bHRzIHRvIDEpXG5cdCAqL1xuXHRnZXRIZWFkZXJJZChjb2x1bW46IEhlYWRlclR5cGUsIGNvbFNwYW4gPSAxKTogc3RyaW5nIHtcblx0XHRpZiAoY29sdW1uID09PSBcInNlbGVjdFwiIHx8IGNvbHVtbiA9PT0gXCJleHBhbmRcIikge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SWQoY29sdW1uKTtcblx0XHR9XG5cblx0XHRsZXQgaWRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IGNvbHVtbjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmICh0aGlzLmhlYWRlcltpXSkge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuXHRcdFx0XHRcdGlkcy5wdXNoKHRoaXMuZ2V0SWQoaSArIGopKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaWRzLmpvaW4oXCIgXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIGNsb3Nlc3QgaGVhZGVyIGJ5IHRyeWluZyB0aGUgYGNvbHVtbmAgYW5kIHRoZW4gd29ya2luZyBpdHMgd2F5IHRvIHRoZSBsZWZ0XG5cdCAqXG5cdCAqIEBwYXJhbSBjb2x1bW4gdGhlIHRhcmdldCBjb2x1bW5cblx0ICovXG5cdGdldEhlYWRlcihjb2x1bW46IG51bWJlcik6IFRhYmxlSGVhZGVySXRlbSB7XG5cdFx0aWYgKCF0aGlzLmhlYWRlcikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IGNvbHVtbjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGhlYWRlckNlbGwgPSB0aGlzLmhlYWRlcltpXTtcblx0XHRcdGlmIChoZWFkZXJDZWxsKSB7XG5cdFx0XHRcdHJldHVybiBoZWFkZXJDZWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaG93IG1hbnkgcm93cyBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcblx0ICovXG5cdHNlbGVjdGVkUm93c0NvdW50KCk6IG51bWJlciB7XG5cdFx0bGV0IGNvdW50ID0gMDtcblx0XHRpZiAodGhpcy5yb3dzU2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLmZvckVhY2gocm93U2VsZWN0ZWQgPT4ge1xuXHRcdFx0XHRpZiAocm93U2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaG93IG1hbnkgcm93cyBpcyBjdXJyZW50bHkgZXhwYW5kZWRcblx0ICovXG5cdGV4cGFuZGVkUm93c0NvdW50KCk6IG51bWJlciB7XG5cdFx0bGV0IGNvdW50ID0gMDtcblx0XHRpZiAodGhpcy5yb3dzRXhwYW5kZWQpIHtcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLmZvckVhY2gocm93RXhwYW5kZWQgPT4ge1xuXHRcdFx0XHRpZiAocm93RXhwYW5kZWQpIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYGluZGV4YHRoIHJvdyBvZiB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0cm93KGluZGV4OiBudW1iZXIpOiBUYWJsZUl0ZW1bXSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnJlYWxSb3dJbmRleChpbmRleCldO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSByb3cgdG8gdGhlIGBpbmRleGB0aCByb3cgb3IgYXBwZW5kcyB0byB0YWJsZSBpZiBpbmRleCBub3QgcHJvdmlkZWQuXG5cdCAqXG5cdCAqIElmIHJvdyBpcyBzaG9ydGVyIHRoYW4gb3RoZXIgcm93cyBvciBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgcGFkZGVkIHdpdGhcblx0ICogZW1wdHkgYFRhYmxlSXRlbWAgZWxlbWVudHMuXG5cdCAqXG5cdCAqIElmIHJvdyBpcyBsb25nZXIgdGhhbiBvdGhlciByb3dzLCBvdGhlcnMgd2lsbCBiZSBleHRlbmRlZCB0byBtYXRjaCBzbyBubyBkYXRhIGlzIGxvc3QuXG5cdCAqXG5cdCAqIElmIGNhbGxlZCBvbiBhbiBlbXB0eSB0YWJsZSB3aXRoIG5vIHBhcmFtZXRlcnMsIGl0IGNyZWF0ZXMgYSAxeDEgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBbcm93XVxuXHQgKiBAcGFyYW0gW2luZGV4XVxuXHQgKi9cblx0YWRkUm93KHJvdz86IFRhYmxlSXRlbVtdLCBpbmRleD86IG51bWJlcikge1xuXHRcdC8vIGlmIHRhYmxlIGVtcHR5IGNyZWF0ZSB0YWJsZSB3aXRoIHJvd1xuXHRcdGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPT09IDAgfHwgdGhpcy5kYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0bGV0IG5ld0RhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRcdG5ld0RhdGEucHVzaChyb3cgPyByb3cgOiBbbmV3IFRhYmxlSXRlbSgpXSk7ICAvLyByb3cgb3Igb25lIGVtcHR5IG9uZSBjb2x1bW4gcm93XG5cdFx0XHR0aGlzLmRhdGEgPSBuZXdEYXRhO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IHJlYWxSb3cgPSByb3c7XG5cdFx0Y29uc3QgY29sdW1uQ291bnQgPSB0aGlzLmRhdGFbMF0ubGVuZ3RoO1xuXG5cdFx0aWYgKHJvdyA9PSBudWxsKSB7XG5cdFx0XHRyZWFsUm93ID0gbmV3IEFycmF5PFRhYmxlSXRlbT4oKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuXHRcdFx0XHRyZWFsUm93LnB1c2gobmV3IFRhYmxlSXRlbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVhbFJvdy5sZW5ndGggPCBjb2x1bW5Db3VudCkge1xuXHRcdFx0Ly8gZXh0ZW5kIHRoZSBsZW5ndGggb2YgcmVhbFJvd1xuXHRcdFx0Y29uc3QgZGlmZmVyZW5jZSA9IGNvbHVtbkNvdW50IC0gcmVhbFJvdy5sZW5ndGg7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZlcmVuY2U7IGkrKykge1xuXHRcdFx0XHRyZWFsUm93LnB1c2gobmV3IFRhYmxlSXRlbSgpKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHJlYWxSb3cubGVuZ3RoID4gY29sdW1uQ291bnQpIHtcblx0XHRcdC8vIGV4dGVuZCB0aGUgbGVuZ3RoIG9mIGhlYWRlclxuXHRcdFx0bGV0IGRpZmZlcmVuY2UgPSByZWFsUm93Lmxlbmd0aCAtIHRoaXMuaGVhZGVyLmxlbmd0aDtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZGlmZmVyZW5jZTsgaisrKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdH1cblx0XHRcdC8vIGV4dGVuZCB0aGUgbGVuZ3RoIG9mIGV2ZXJ5IG90aGVyIHJvd1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bGV0IGN1cnJlbnRSb3cgPSB0aGlzLmRhdGFbaV07XG5cdFx0XHRcdGRpZmZlcmVuY2UgPSByZWFsUm93Lmxlbmd0aCAtIGN1cnJlbnRSb3cubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGRpZmZlcmVuY2U7IGorKykge1xuXHRcdFx0XHRcdGN1cnJlbnRSb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGluZGV4ID09IG51bGwpIHtcblx0XHRcdHRoaXMuZGF0YS5wdXNoKHJlYWxSb3cpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c1NlbGVjdGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLnB1c2goZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0V4cGFuZGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLnB1c2goZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0NvbnRleHQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ29udGV4dC5wdXNoKHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ2xhc3MgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ2xhc3MucHVzaCh1bmRlZmluZWQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCByaSA9IHRoaXMucmVhbFJvd0luZGV4KGluZGV4KTtcblx0XHRcdHRoaXMuZGF0YS5zcGxpY2UocmksIDAsIHJlYWxSb3cpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c1NlbGVjdGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLnNwbGljZShyaSwgMCwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0V4cGFuZGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLnNwbGljZShyaSwgMCwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0NvbnRleHQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ29udGV4dC5zcGxpY2UocmksIDAsIHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ2xhc3MgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ2xhc3Muc3BsaWNlKHJpLCAwLCB1bmRlZmluZWQpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBgaW5kZXhgdGggcm93LlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGRlbGV0ZVJvdyhpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgcnJpID0gdGhpcy5yZWFsUm93SW5kZXgoaW5kZXgpO1xuXHRcdHRoaXMuZGF0YS5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NTZWxlY3RlZC5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NFeHBhbmRlZC5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NDb250ZXh0LnNwbGljZShycmksIDEpO1xuXHRcdHRoaXMucm93c0NsYXNzLnNwbGljZShycmksIDEpO1xuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdGhhc0V4cGFuZGFibGVSb3dzKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGEuc29tZShkYXRhID0+IGRhdGEuc29tZShkID0+IGQgJiYgZC5leHBhbmRlZERhdGEpKTsgLy8gY2hlY2tpbmcgZm9yIHNvbWUgaW4gMkQgYXJyYXlcblx0fVxuXG5cdGlzUm93RXhwYW5kYWJsZShpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVtpbmRleF0uc29tZShkID0+IGQgJiYgZC5leHBhbmRlZERhdGEpO1xuXHR9XG5cblx0aXNSb3dFeHBhbmRlZChpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMucm93c0V4cGFuZGVkW2luZGV4XTtcblx0fVxuXG5cdGdldFJvd0NvbnRleHQoaW5kZXg6IG51bWJlcikge1xuXHRcdHJldHVybiB0aGlzLnJvd3NDb250ZXh0W2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBpbmRleGB0aCBjb2x1bW4gb2YgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGNvbHVtbihpbmRleDogbnVtYmVyKTogVGFibGVJdGVtW10ge1xuXHRcdGxldCBjb2x1bW4gPSBuZXcgQXJyYXk8VGFibGVJdGVtPigpO1xuXHRcdGNvbnN0IHJpID0gdGhpcy5yZWFsQ29sdW1uSW5kZXgoaW5kZXgpO1xuXHRcdGNvbnN0IHJjID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmM7IGkrKykge1xuXHRcdFx0Y29uc3Qgcm93ID0gdGhpcy5kYXRhW2ldO1xuXHRcdFx0Y29sdW1uLnB1c2gocm93W3JpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbHVtbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY29sdW1uIHRvIHRoZSBgaW5kZXhgdGggY29sdW1uIG9yIGFwcGVuZHMgdG8gdGFibGUgaWYgaW5kZXggbm90IHByb3ZpZGVkLlxuXHQgKlxuXHQgKiBJZiBjb2x1bW4gaXMgc2hvcnRlciB0aGFuIG90aGVyIGNvbHVtbnMgb3Igbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIHBhZGRlZCB3aXRoXG5cdCAqIGVtcHR5IGBUYWJsZUl0ZW1gIGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBJZiBjb2x1bW4gaXMgbG9uZ2VyIHRoYW4gb3RoZXIgY29sdW1ucywgb3RoZXJzIHdpbGwgYmUgZXh0ZW5kZWQgdG8gbWF0Y2ggc28gbm8gZGF0YSBpcyBsb3N0LlxuXHQgKlxuXHQgKiBJZiBjYWxsZWQgb24gYW4gZW1wdHkgdGFibGUgd2l0aCBubyBwYXJhbWV0ZXJzLCBpdCBjcmVhdGVzIGEgMXgxIHRhYmxlLlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gW2NvbHVtbl1cblx0ICogQHBhcmFtIFtpbmRleF1cblx0ICovXG5cdGFkZENvbHVtbihjb2x1bW4/OiBUYWJsZUl0ZW1bXSwgaW5kZXg/OiBudW1iZXIpIHtcblx0XHQvLyBpZiB0YWJsZSBlbXB0eSBjcmVhdGUgdGFibGUgd2l0aCByb3dcblx0XHRpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoID09PSAwIHx8IHRoaXMuZGF0YVswXS5sZW5ndGggPT09IDApIHtcblx0XHRcdGxldCBuZXdEYXRhID0gbmV3IEFycmF5PEFycmF5PFRhYmxlSXRlbT4+KCk7XG5cdFx0XHRpZiAoY29sdW1uID09IG51bGwpIHtcblx0XHRcdFx0bmV3RGF0YS5wdXNoKFtuZXcgVGFibGVJdGVtKCldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IGl0ZW0gPSBjb2x1bW5baV07XG5cdFx0XHRcdFx0bmV3RGF0YS5wdXNoKFtpdGVtXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZGF0YSA9IG5ld0RhdGE7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgcmMgPSB0aGlzLmRhdGEubGVuZ3RoOyAgLy8gcm93IGNvdW50XG5cdFx0bGV0IGNpID0gdGhpcy5yZWFsQ29sdW1uSW5kZXgoaW5kZXgpO1xuXG5cdFx0Ly8gYXBwZW5kIG1pc3Npbmcgcm93c1xuXHRcdGZvciAobGV0IGkgPSAwOyBjb2x1bW4gIT0gbnVsbCAmJiBpIDwgY29sdW1uLmxlbmd0aCAtIHJjOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkUm93KCk7XG5cdFx0fVxuXHRcdHJjID0gdGhpcy5kYXRhLmxlbmd0aDtcblx0XHRpZiAoaW5kZXggPT0gbnVsbCkge1xuXHRcdFx0Ly8gYXBwZW5kIHRvIGVuZFxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYzsgaSsrKSB7XG5cdFx0XHRcdGxldCByb3cgPSB0aGlzLmRhdGFbaV07XG5cdFx0XHRcdHJvdy5wdXNoKGNvbHVtbiA9PSBudWxsIHx8IGNvbHVtbltpXSA9PSBudWxsID8gbmV3IFRhYmxlSXRlbSgpIDogY29sdW1uW2ldKTtcblx0XHRcdH1cblx0XHRcdC8vIHVwZGF0ZSBoZWFkZXIgaWYgbm90IGFscmVhZHkgc2V0IGJ5IHVzZXJcblx0XHRcdGlmICh0aGlzLmhlYWRlci5sZW5ndGggPCB0aGlzLmRhdGFbMF0ubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuaGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGluZGV4ID49IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gaWYgdHJ5aW5nIHRvIGFwcGVuZFxuXHRcdFx0XHRjaSsrO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW5zZXJ0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJjOyBpKyspIHtcblx0XHRcdFx0bGV0IHJvdyA9IHRoaXMuZGF0YVtpXTtcblx0XHRcdFx0cm93LnNwbGljZShjaSwgMCwgY29sdW1uID09IG51bGwgfHwgY29sdW1uW2ldID09IG51bGwgPyBuZXcgVGFibGVJdGVtKCkgOiBjb2x1bW5baV0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGhlYWRlciBpZiBub3QgYWxyZWFkeSBzZXQgYnkgdXNlclxuXHRcdFx0aWYgKHRoaXMuaGVhZGVyLmxlbmd0aCA8IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5oZWFkZXIuc3BsaWNlKGNpLCAwLCBuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBgaW5kZXhgdGggY29sdW1uLlxuXHQgKlxuXHQgKiBOZWdhdGl2ZSBpbmRleCBzdGFydHMgZnJvbSB0aGUgZW5kLiAtMSBiZWluZyB0aGUgbGFzdCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGRlbGV0ZUNvbHVtbihpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgcmNpID0gdGhpcy5yZWFsQ29sdW1uSW5kZXgoaW5kZXgpO1xuXHRcdGNvbnN0IHJvd0NvdW50ID0gdGhpcy5kYXRhLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcblx0XHRcdHRoaXMuZGF0YVtpXS5zcGxpY2UocmNpLCAxKTtcblx0XHR9XG5cdFx0Ly8gdXBkYXRlIGhlYWRlciBpZiBub3QgYWxyZWFkeSBzZXQgYnkgdXNlclxuXHRcdGlmICh0aGlzLmhlYWRlci5sZW5ndGggPiB0aGlzLmRhdGFbMF0ubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmhlYWRlci5zcGxpY2UocmNpLCAxKTtcblx0XHR9XG5cblx0XHR0aGlzLmRhdGFDaGFuZ2UuZW1pdCgpO1xuXHR9XG5cblx0bW92ZUNvbHVtbihpbmRleEZyb206IG51bWJlciwgaW5kZXhUbzogbnVtYmVyKSB7XG5cdFx0Y29uc3QgaGVhZGVyRnJvbSA9IHRoaXMuaGVhZGVyW2luZGV4RnJvbV07XG5cblx0XHR0aGlzLmFkZENvbHVtbih0aGlzLmNvbHVtbihpbmRleEZyb20pLCBpbmRleFRvKTtcblx0XHR0aGlzLmRlbGV0ZUNvbHVtbihpbmRleEZyb20gKyAoaW5kZXhUbyA8IGluZGV4RnJvbSA/IDEgOiAwKSk7XG5cblx0XHR0aGlzLmhlYWRlcltpbmRleFRvICsgKGluZGV4VG8gPiBpbmRleEZyb20gPyAtMSA6IDApXSA9IGhlYWRlckZyb207XG5cdH1cblxuXHQvKipcblx0ICogU29ydHMgdGhlIGRhdGEgY3VycmVudGx5IHByZXNlbnQgaW4gdGhlIG1vZGVsIGJhc2VkIG9uIGBjb21wYXJlKClgXG5cdCAqXG5cdCAqIERpcmVjdGlvbiBpcyBzZXQgYnkgYGFzY2VuZGluZ2AgYW5kIGBkZXNjZW5kaW5nYCBwcm9wZXJ0aWVzIG9mIGBUYWJsZUhlYWRlckl0ZW1gXG5cdCAqIGluIGBpbmRleGB0aCBjb2x1bW4uXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgY29sdW1uIGJhc2VkIG9uIHdoaWNoIGl0J3Mgc29ydGluZ1xuXHQgKi9cblx0c29ydChpbmRleDogbnVtYmVyKSB7XG5cdFx0dGhpcy5wdXNoUm93U3RhdGVUb01vZGVsRGF0YSgpO1xuXHRcdHRoaXMuZGF0YS5zb3J0KChhLCBiKSA9PiAodGhpcy5oZWFkZXJbaW5kZXhdLmRlc2NlbmRpbmcgPyAtMSA6IDEpICogdGhpcy5oZWFkZXJbaW5kZXhdLmNvbXBhcmUoYVtpbmRleF0sIGJbaW5kZXhdKSk7XG5cdFx0dGhpcy5wb3BSb3dTdGF0ZUZyb21Nb2RlbERhdGEoKTtcblx0XHR0aGlzLmhlYWRlci5mb3JFYWNoKGNvbHVtbiA9PiBjb2x1bW4uc29ydGVkID0gZmFsc2UpO1xuXHRcdHRoaXMuaGVhZGVyW2luZGV4XS5zb3J0ZWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYHJvd3NTZWxlY3RlZGAgYW5kIGByb3dzRXhwYW5kZWRgIGluZm8gdG8gbW9kZWwgZGF0YS5cblx0ICpcblx0ICogV2hlbiBzb3J0aW5nIHJvd3MsIGRvIHRoaXMgZmlyc3Qgc28gaW5mb3JtYXRpb24gYWJvdXQgcm93IHNlbGVjdGlvblxuXHQgKiBnZXRzIHNvcnRlZCB3aXRoIHRoZSBvdGhlciByb3cgaW5mby5cblx0ICpcblx0ICogQ2FsbCBgcG9wUm93U2VsZWN0aW9uRnJvbU1vZGVsRGF0YSgpYCBhZnRlciBzb3J0aW5nIHRvIG1ha2UgZXZlcnl0aGluZ1xuXHQgKiByaWdodCB3aXRoIHRoZSB3b3JsZCBhZ2Fpbi5cblx0ICovXG5cdHB1c2hSb3dTdGF0ZVRvTW9kZWxEYXRhKCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCByb3dTZWxlY3RlZE1hcmsgPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dTZWxlY3RlZE1hcmsuZGF0YSA9IHRoaXMucm93c1NlbGVjdGVkW2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93U2VsZWN0ZWRNYXJrKTtcblxuXHRcdFx0Y29uc3Qgcm93RXhwYW5kZWRNYXJrID0gbmV3IFRhYmxlSXRlbSgpO1xuXHRcdFx0cm93RXhwYW5kZWRNYXJrLmRhdGEgPSB0aGlzLnJvd3NFeHBhbmRlZFtpXTtcblx0XHRcdHRoaXMuZGF0YVtpXS5wdXNoKHJvd0V4cGFuZGVkTWFyayk7XG5cblx0XHRcdGNvbnN0IHJvd0NvbnRleHQgPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dDb250ZXh0LmRhdGEgPSB0aGlzLnJvd3NDb250ZXh0W2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93Q29udGV4dCk7XG5cblx0XHRcdGNvbnN0IHJvd0NsYXNzID0gbmV3IFRhYmxlSXRlbSgpO1xuXHRcdFx0cm93Q2xhc3MuZGF0YSA9IHRoaXMucm93c0NsYXNzW2ldO1xuXHRcdFx0dGhpcy5kYXRhW2ldLnB1c2gocm93Q2xhc3MpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXN0b3JlcyBgcm93c1NlbGVjdGVkYCBmcm9tIGRhdGEgcHVzaGVkIGJ5IGBwdXNoUm93U2VsZWN0aW9uVG9Nb2RlbERhdGEoKWBcblx0ICpcblx0ICogQ2FsbCBhZnRlciBzb3J0aW5nIGRhdGEgKGlmIHlvdSBwcmV2aW91c2x5IHB1c2hlZCB0byBtYWludGFpbiBzZWxlY3Rpb24gb3JkZXIpXG5cdCAqIHRvIG1ha2UgZXZlcnl0aGluZyByaWdodCB3aXRoIHRoZSB3b3JsZCBhZ2Fpbi5cblx0ICovXG5cdHBvcFJvd1N0YXRlRnJvbU1vZGVsRGF0YSgpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5yb3dzQ2xhc3NbaV0gPSB0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c0NvbnRleHRbaV0gPSB0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkW2ldID0gISF0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkW2ldID0gISF0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHJvdyBpcyBmaWx0ZXJlZCBvdXQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgZmlsdGVycyBpbiBoZWFkZXIgZmlsdGVycyBvdXQgdGhlIGBpbmRleGB0aCByb3dcblx0ICovXG5cdGlzUm93RmlsdGVyZWQoaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdGNvbnN0IHJlYWxJbmRleCA9IHRoaXMucmVhbFJvd0luZGV4KGluZGV4KTtcblx0XHRyZXR1cm4gdGhpcy5oZWFkZXIuc29tZSgoaXRlbSwgaSkgPT4gaXRlbSAmJiBpdGVtLmZpbHRlcih0aGlzLnJvdyhyZWFsSW5kZXgpW2ldKSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0L2Rlc2VsZWN0IGBpbmRleGB0aCByb3cgYmFzZWQgb24gdmFsdWVcblx0ICpcblx0ICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSByb3cgdG8gc2VsZWN0XG5cdCAqIEBwYXJhbSB2YWx1ZSBzdGF0ZSB0byBzZXQgdGhlIHJvdyB0by4gRGVmYXVsdHMgdG8gYHRydWVgXG5cdCAqL1xuXHRzZWxlY3RSb3coaW5kZXg6IG51bWJlciwgdmFsdWUgPSB0cnVlKSB7XG5cdFx0aWYgKHRoaXMuaXNSb3dEaXNhYmxlZChpbmRleCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWRbaW5kZXhdID0gdmFsdWU7XG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWRDaGFuZ2UuZW1pdChpbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0cyBvciBkZXNlbGVjdHMgYWxsIHJvd3MgaW4gdGhlIG1vZGVsXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSBzdGF0ZSB0byBzZXQgYWxsIHJvd3MgdG8uIERlZmF1bHRzIHRvIGB0cnVlYFxuXHQgKi9cblx0c2VsZWN0QWxsKHZhbHVlID0gdHJ1ZSkge1xuXHRcdGlmICh0aGlzLmRhdGEubGVuZ3RoID49IDEgJiYgdGhpcy5kYXRhWzBdLmxlbmd0aCA+PSAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93c1NlbGVjdGVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0Um93KGksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5zZWxlY3RBbGxDaGFuZ2UubmV4dCh2YWx1ZSk7XG5cdH1cblxuXHRpc1Jvd1NlbGVjdGVkKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5yb3dzU2VsZWN0ZWRbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiByb3cgaXMgZGlzYWJsZWQgb3Igbm90LlxuXHQgKi9cblx0aXNSb3dEaXNhYmxlZChpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3Qgcm93ID0gdGhpcy5kYXRhW2luZGV4XSBhcyBUYWJsZVJvdztcblx0XHRyZXR1cm4gISFyb3cuZGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kcy9Db2xsYXBzZXMgYGluZGV4YHRoIHJvdyBiYXNlZCBvbiB2YWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXggaW5kZXggb2YgdGhlIHJvdyB0byBleHBhbmQgb3IgY29sbGFwc2Vcblx0ICogQHBhcmFtIHZhbHVlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSByb3cuIGB0cnVlYCBpcyBleHBhbmRlZCBhbmQgYGZhbHNlYCBpcyBjb2xsYXBzZWRcblx0ICovXG5cdGV4cGFuZFJvdyhpbmRleDogbnVtYmVyLCB2YWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLnJvd3NFeHBhbmRlZFtpbmRleF0gPSB2YWx1ZTtcblx0XHR0aGlzLnJvd3NFeHBhbmRlZENoYW5nZS5lbWl0KGluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0cnVlIGluZGV4IG9mIGEgcm93IGJhc2VkIG9uIGl0J3MgcmVsYXRpdmUgcG9zaXRpb24uXG5cdCAqIExpa2UgaW4gUHl0aG9uLCBwb3NpdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmRcblx0ICogbmVnYXRpdmUgbnVtYmVycyBzdGFydCBmcm9tIHRoZSBib3R0b20uXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0cHJvdGVjdGVkIHJlYWxSb3dJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsSW5kZXgoaW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRydWUgaW5kZXggb2YgYSBjb2x1bW4gYmFzZWQgb24gaXQncyByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogTGlrZSBpbiBQeXRob24sIHBvc2l0aXZlIG51bWJlcnMgc3RhcnQgZnJvbSB0aGUgdG9wIGFuZFxuXHQgKiBuZWdhdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIGJvdHRvbS5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqL1xuXHRwcm90ZWN0ZWQgcmVhbENvbHVtbkluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnJlYWxJbmRleChpbmRleCwgdGhpcy5kYXRhWzBdLmxlbmd0aCk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJpYyBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIHJlYWwgaW5kZXggb2Ygc29tZXRoaW5nLlxuXHQgKiBVc2VkIGJ5IGByZWFsUm93SW5kZXgoKWAgYW5kIGByZWFsQ29sdW1uSW5kZXgoKWBcblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBsZW5ndGhcblx0ICovXG5cdHByb3RlY3RlZCByZWFsSW5kZXgoaW5kZXg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGlmIChpbmRleCA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKGluZGV4ID49IDApIHtcblx0XHRcdHJldHVybiBpbmRleCA+PSBsZW5ndGggPyBsZW5ndGggLSAxIDogaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAtaW5kZXggPj0gbGVuZ3RoID8gMCA6IGxlbmd0aCArIGluZGV4O1xuXHRcdH1cblx0fVxufVxuIl19